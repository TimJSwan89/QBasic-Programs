<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0037)http://tedfelix.com/qbasic/index.html -->
<HTML><HEAD><TITLE>QBASIC Programming for Kids</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><!-- "page-break-before: always" works just fine in IE 6.  I cannot
       figure out how to get "page-break-inside: avoid" to work         -->
<STYLE type=text/css>CODE {
	PAGE-BREAK-BEFORE: auto; PAGE-BREAK-AFTER: auto; page-break-inside: avoid
}
PRE {
	PAGE-BREAK-BEFORE: auto; PAGE-BREAK-AFTER: auto; page-break-inside: avoid
}
P {
	PAGE-BREAK-BEFORE: auto; PAGE-BREAK-AFTER: auto; page-break-inside: avoid
}
UNKNOWN {
	PAGE-BREAK-AFTER: always
}
</STYLE>

<META content="MSHTML 6.00.2900.2802" name=GENERATOR></HEAD>
<BODY>
<CENTER>
<H1>QBASIC Programming for Kids</H1></CENTER>
<CENTER>
<H2>by Ted Felix</H2></CENTER>
<HR>

<H1>Introduction</H1>
<P>You've probably used computers to play games, and to write reports for 
school. It's a lot more fun to create your own games to play on the computer. 
This book will help you get started by using QBASIC. QBASIC is a programming 
language. With a programming language you can tell the computer what you want it 
to do. It's a lot like giving someone directions to your house. The computer 
follows each step and does exactly what you tell it. By programming the computer 
you can solve math problems, create art or music, and even make new games. It's 
all up to you.</P>
<P>The best way to start with this book is to type in some of the small programs 
you'll find in each of the chapters. You might need to work through Chapter 1 
first. An adult can help you get up to speed quickly. Then change the programs 
to do what you want them to do. Before long, you'll be writing your own 
programs.</P>
<HR>

<H1>Introduction for Parents and Teachers</H1>
<P>Kids love computers. They also like to create, and to have some control over 
the world around them. The computer will do whatever it is told. It may not seem 
that way at times, but it is true.</P>
<P>When I was a kid, all we had was the "old BASIC". It had line numbers and 
didn't teach good structured programming habits. QBASIC is a much better 
learning tool. With the information acquired from this book, one can move on to 
a more advanced QBASIC book (if you can find one). After becoming proficient in 
QBASIC, one can move on to more powerful languages like Visual Basic, Java, C, 
and eventually C++. I would suggest a course of study like this:</P>
<UL>
  <LI>Logo - Teach FORWARD, LEFT, RIGHT, TO, REPEAT. This shows the basics of 
  programming. You can walk kids through all this step by step. You'll be 
  surprised how much they'll learn. Very young kids can have a lot of fun with 
  Logo. Just don't get too deep. Make sure it is a lot of fun. 
  <LI>QBASIC - QBASIC is more like conventional programming languages than Logo, 
  so before getting too deep into Logo, it's a good idea to switch to QBASIC. 
  Kids will be resistant for two reasons: no more turtle (DRAW is similar, see 
  the Graphics chapter), and the fact that it's a new language. They'll get over 
  it. You can teach the basics of QBASIC interactively, but at some point, you 
  need to turn them loose with this book, and let them type in the examples and 
  ask you questions. 
  <LI>Visual BASIC - All of the skills learned in QBASIC transfer nicely to 
  Visual BASIC. Here kids can finally learn to make real windows programs. 
  Visual BASIC also includes object oriented programming features that can be 
  introduced to help manage larger programs. Visual BASIC versions 4 through 6 
  have varying levels of Object Oriented support, while Visual BASIC 7.0 (.net) 
  is a complete Object Oriented language. 
  <LI>Java - Introduce "C" and its cousins gently with Java. Object Oriented 
  programming concepts can be introduced here or in Visual BASIC. Microsoft's C# 
  is another alternative to Java. The big draw here is being able to develop 
  cool applets to run on the web. 
  <LI>C - Since "C" is probably the most marketable language of all, it has to 
  be learned if you are serious about a programming career. The big plus for "C" 
  is raw speed. Even compiled BASIC programs can't compete. When your kid starts 
  really pushing the limits of BASIC, keep mentioning "C" as being even better. 
  That will make them very curious. 
  <LI>C++ - A better C, and object oriented programming concepts make C++ a 
  must-learn. Not to mention the fact that C++ programmers are hard to find and 
  are very well paid. The raw speed of C and the object oriented power of Java 
  all wrapped up into one. 
  <LI>Assembler - At some point, the truth about what's really going on under 
  the covers must be told. Assembler can be introduced at any time throughout 
  the learning process to explain how the computer really works. Keep bringing 
  it up as being even faster than C. </LI></UL>
<P>Obviously, you'll have to determine when your child is ready to move from one 
language to another. My rule is that QBASIC should be introduced at a point 
where children can learn on their own from this book (10 or 11 years old). Then 
let them go and master it by themselves. This gives them a huge feeling of 
accomplishment. As you see them reaching the limits of what can be done, 
introduce them to other languages. The jump from QBASIC to Visual BASIC should 
be made when it is obvious that your child's programs could benefit from a 
Graphical User Interface (GUI). It's up to you to determine when they are 
ready.</P>
<P>If you are an elementary school teacher interested in teaching programming or 
software development (aka software engineering) to kids, I'd suggest starting 
with Logo at the third or fourth grade level. Then move to QBASIC for fourth, 
fifth, sixth, etc.... Having to teach a large number of students always presents 
a challenge as they will each have different abilities. Computer programming 
fits in perfectly with a math curriculum since it helps the students become more 
aware of numbers and how they "work". Because of learning to program in BASIC, I 
understood trigonometry by seventh grade. I had to, because the kinds of 
programs I was writing required that I understand trig, and apply it. What could 
be a better motivation for learning? Beyond sixth grade, I suspect one could 
introduce Visual BASIC, and continue on up through Java/C# and into C/C++ at the 
High School level. If anyone has any experience teaching programming at the 
elementary or middle school level, let me know what works for you, and I'll add 
it here.</P>
<P>At age 11, I learned from a book very similar in style to this one. It was 
the TRS-80 User's Manual and it came with my first Personal Computer, the Radio 
Shack TRS-80. I haven't stopped programming since then. I hope this book has the 
same effect on your kids (or maybe even you). Please <A 
href="http://tedfelix.com/email.html">email me</A> with any comments or 
suggestions to improve this book. My email address:</P>
<P><IMG src="Programming Tutorial_files/email.png"></P>
<P>You can find more information on my Computer Science for Kids page:</P>
<P><A href="http://tedfelix.com/cs4kids">http://tedfelix.com/cs4kids</A> - 
Computer Science for Kids</P>
<P>And in case you are looking at a mirror site, the latest version of this book 
is always kept here:</P>
<P><A href="http://tedfelix.com/qbasic">http://tedfelix.com/qbasic</A> - QBASIC 
Programming for Kids</P>
<P>I hope you and your kids have lots of fun.</P>
<HR>

<H1 style="PAGE-BREAK-BEFORE: always">Chapter 1 - Getting Started</H1>
<H2>Getting to DOS</H2>
<P>To run QBASIC we need to get to DOS.</P>
<P>If you are using Windows 3.1, you'll need to find the "Main" program group 
and look for an icon called "MS-DOS Prompt". Double-click on it to get the 
"<CODE>C:\WINDOWS&gt;<BLINK>_</BLINK></CODE>" prompt in a black window with 
white text.</P>
<P>In Windows 95, click on "Start", then "Programs", then "MS-DOS 
Prompt".<BR><BR><IMG src="Programming Tutorial_files/StartDOS.gif"> 
<P>In Windows XP, it is called the "Command Prompt" and you can get to it by 
clicking on Start, then All Programs, then Accessories, then Command Prompt.</P>
<P>You will get the black window with the 
"<CODE>C:\WINDOWS&gt;<BLINK>_</BLINK></CODE>" prompt.<BR><BR><IMG 
src="Programming Tutorial_files/DOSPrompt.jpg"> 
<P>Now you're ready for the next step. 
<H2>Starting QBASIC</H2>
<P>QBASIC may not be on your computer. Don't be alarmed, <A 
href="http://tedfelix.com/qbasic/index.html#appa">Appendix A</A> shows you how 
to get it there. At the "<CODE>C:\WINDOWS&gt;<BLINK>_</BLINK></CODE>" prompt, 
try typing: <BR><BR><CODE><PRE>     qbasic
</PRE></CODE>and press the &lt;Enter&gt; key.<BR><BR><IMG 
src="Programming Tutorial_files/QBASIC1.gif"> 
<P>If you get a blue screen with something about a "Survival Guide", you made 
it!<BR><BR><IMG src="Programming Tutorial_files/QBASIC.jpg"> 
<P>If instead you got something about a "Bad command or file name",<BR><BR><IMG 
src="Programming Tutorial_files/BadCommand.jpg"> 
<P>you need to check out <A 
href="http://tedfelix.com/qbasic/index.html#appa">Appendix A</A> to get QBASIC 
installed on your machine. Don't worry, we'll wait right here for you. 
<H2>Survival Guide?</H2>
<P>We won't be using the survival guide right now, so press the &lt;Esc&gt; 
(escape) key to get the big blank blue screen. <BR><BR><IMG 
src="Programming Tutorial_files/QBASIC2.jpg"> 
<P>Now we're ready to program. 
<H2>Getting Out</H2>
<P>If you need to leave QBASIC, you can click on "File" on QBASIC's menu and 
then "Exit" to get back to DOS.<BR><BR><IMG 
src="Programming Tutorial_files/FileExit.gif"> 
<P>At the "<CODE>C:\WINDOWS&gt;<BLINK>_</BLINK></CODE>" prompt, type: 
<BR><BR><CODE><PRE>     exit
</PRE></CODE>and then press the &lt;Enter&gt; key to get rid of the DOS 
window.<BR><BR><IMG src="Programming Tutorial_files/DOSExit.gif"> 
<HR>

<H1>Chapter 2 - PRINT</H1>
<H2>Follow Along</H2>
<P>I'm assuming you will be following along with QBASIC in front of you. This 
won't be much fun if you aren't. So power up the computer and get QBASIC's blue 
screen up in front of you. Go ahead and press the &lt;Esc&gt; key to "clear this 
dialog box" when it asks you. 
<H2>QBASIC's Screen</H2>
<P>Before we start, let's take a look at QBASIC's screen. At the top is QBASIC's 
menu. The menu has the following items: File, Edit, View, Search, Run, Debug, 
Options, and Help. <BR><BR><IMG src="Programming Tutorial_files/qbmenu.jpg"> 
<P>Clicking on any of these with the mouse will show more selections. 
<P>Just under the menu is the word "Untitled". This means we haven't given the 
current program a name. This will change when we learn to save programs. The big 
blue area with the blinking cursor ( <CODE><BLINK>_</BLINK></CODE> ) is where we 
can enter our programs. 
<P>These are the most important areas to know for right now. We will learn more 
about the rest of QBASIC's screen as we go along. 
<H2>QBASIC Editor</H2>
<P>If you've used your computer to do school work or write a report, you'll 
notice that most of the editing keys (&lt;Backspace&gt;, &lt;Delete&gt;, 
&lt;Insert&gt;...) work just the way they always do. In case you haven't used 
these keys before, here's a list: 
<UL>
  <LI>&lt;Backspace&gt; - Removes the character to the left of the cursor 
  <LI>&lt;Delete&gt; - Removes the character at the cursor 
  <LI>&lt;Left Arrow&gt; - Moves the cursor left 
  <LI>&lt;Right Arrow&gt; - Moves the cursor right 
  <LI>&lt;Up Arrow&gt; - Moves the cursor up 
  <LI>&lt;Down Arrow&gt; - Moves the cursor down 
  <LI>&lt;Home&gt; - Moves the cursor to the start of a line 
  <LI>&lt;End&gt; - Moves the cursor to the end of a line </LI></UL>
<H2>Your First Program.</H2>With the blinking cursor ( 
<CODE><BLINK>_</BLINK></CODE> ) at the top-left corner of the screen, type this: 
<BR><BR><CODE><PRE>     PRINT "Welcome to QBASIC.  Your wish is my command."
</PRE></CODE>Make sure it looks exactly like that. The quotation marks 
(<CODE>"</CODE>) are very important. If you make any mistakes, use the 
&lt;Backspace&gt; key to correct them. <BR><BR><IMG 
src="Programming Tutorial_files/wish.gif"> 
<H2>Running Your Program.</H2>
<P>That's great, but what does it do? You have to run it to find out. Look for 
the word "Run" on QBASIC's menu at the top of the screen. Click on it. Now you 
will see a menu with a list of selections (Start, Restart, and Continue). Click 
on Start to run your program. You may have to look around on the screen a bit, 
but you should find your message: <BR><BR><CODE><PRE>     C:\WINDOWS&gt; qbasic
     Welcome to QBASIC.  Your wish is my command.
</PRE></CODE>
<H2>PRINT</H2>
<P>PRINT prints things to the screen. Don't forget to put what you want to say 
in double-quotation marks ("). 
<H2>Press any key to continue?</H2>
<P>At the bottom of the screen you will see a message "Press any key to 
continue". Press &lt;Enter&gt; to get back to QBASIC. This is QBASIC's way of 
giving you enough time to see what your program did. 
<P>As a cool shortcut, use ? for PRINT. Try it. Press &lt;Enter&gt; to start 
typing on a new line. Now type this: <BR><BR><CODE><PRE>     ? "Programming is fun." 
</PRE></CODE>and press &lt;Enter&gt; again. 
<P>Isn't that nice? The ? becomes the word PRINT. That should save us a lot of 
typing in the long run. 
<P>You can try running the program again (remember? Click on Run, then Start on 
the menu). You should see something like this: <BR><BR><CODE><PRE>C:\WINDOWS&gt; qbasic
Welcome to QBASIC.  Your wish is my command.
Welcome to QBASIC.  Your wish is my command.
Programming is fun.
</PRE></CODE>
<H2>Learned</H2>
<UL>
  <LI>QBASIC screen 
  <LI>Editing Keys 
  <LI>PRINT 
  <LI>Run | Start 
  <LI>? </LI></UL>
<HR>

<H1 style="PAGE-BREAK-BEFORE: always">Chapter 3 - CLS</H1>
<P>It was probably a bit hard to find your messages on the screen with that last 
program. Wouldn't it be nice to be able to clear all that stuff off the screen? 
"CLS", which stands for CLear Screen, is just the ticket. You will need to put 
CLS at the very top of your program to clear the screen before you print 
anything. 
<H2>Inserting a new line at the top.</H2>
<P>To make CLS the first line of your program, follow these steps: 
<UL>
  <LI>Press the &lt;Home&gt; key to get to the beginning of the current line. 
  <LI>Press the &lt;Up Arrow&gt; key once or twice to get the cursor to the top 
  of the program. 
  <LI>Press the &lt;Enter&gt; key to get a new line. 
  <LI>Press the &lt;Up Arrow&gt; key once to get the cursor on the new blank 
  line. 
  <LI>Type CLS </LI></UL>
<P>Now your program should look like this: <BR><BR><CODE><PRE>     CLS
     PRINT "Welcome to QBASIC.  Your wish is my command."
     PRINT "Programming is fun."
</PRE></CODE>
<P>Run it. Remember, click on Run and then Start in QBASIC's menu. You can also 
run the program by pressing the &lt;Shift&gt; key and holding it down while 
pressing &lt;F5&gt; (that's what Shift+F5 means on the menu). Another handy 
shortcut. 
<P>That's much better. Only your message is on the screen, which is the way it 
should be. 
<H2>Learned</H2>
<UL>
  <LI>CLS 
  <LI>Shift+F5 </LI></UL>
<HR>

<H1>Chapter 4 - DO...LOOP</H1>
<P>Let's start a new program. To get rid of the old program, click on "File" on 
QBASIC's menu and you will see the File menu with New, Open..., Save, and 
others. Click on "New". QBASIC will now tell you that your current program is 
not saved, and it will ask if you want to "Save it now?". Let's not save it. You 
can always type it in again. Click on &lt; No &gt; with the mouse. We'll learn 
how to save programs in Chapter 8. 
<P>Now you should have a clean blue screen. Type in this program: <BR><BR><CODE><PRE>     DO
       PRINT "Ted was here ";
     LOOP
</PRE></CODE>
<P>Make sure you get the semi-colon (;) at the end of the PRINT line, and the 
space between the word "here" and the last quotation mark. You don't need to use 
my name, put yours in there instead ("Jack was here ", or whatever). Now run it. 

<H2>DO...LOOP</H2>
<P>DO and LOOP will do whatever is between the DO and the LOOP over and over 
again. 
<H2>Give me a Break!</H2>
<P>Ok, that's great. HOW DO I STOP IT!? Press the &lt;Ctrl&gt; (Control) key and 
hold it down while pressing the &lt;Pause&gt; key. The &lt;Pause&gt; key is 
usually at the top of the keyboard and all the way over to the right. This is 
called "pressing the &lt;Break&gt; key." Don't worry, it doesn't really break 
your program, it just stops it and takes you back to QBASIC. Maybe it should 
have been called the "brake" key.</P>
<P>On laptop keyboards, the break key might be a little harder to figure out. 
Sometimes you have to press the "Fn" key followed by the key that says break. 
Sometimes it is color-coded to help you figure it out. You'll know you have it 
when the program stops and the editor comes back up.</P>
<H2>Neatness Counts</H2>
<P>Notice that PRINT has two spaces in front of it. This is called "indenting" 
and it makes the program easier to read. You can see the beginning and the end 
of the DO...LOOP more clearly. QBASIC doesn't care about indenting, only people 
do. It's important to make your programs look nice so other people can read 
them. 
<H2>Learned</H2>
<UL>
  <LI>File | New 
  <LI>DO...LOOP 
  <LI>&lt;Break&gt; </LI></UL>
<HR>

<H1>Chapter 5 - INPUT</H1>
<P>So far our programs have only talked to us. Let's write one that will listen. 
Get rid of the previous program by clicking on File, then New on QBASIC's menu. 
Click on &lt; No &gt; when it asks if you want to save the old program now. Try 
this: <BR><BR><CODE><PRE>     CLS
     INPUT "Enter your name: ", Name$
     PRINT "Hello, "; Name$; ".  How are you today?"
</PRE></CODE>
<P>Don't forget the comma (,) between "Enter your name: " and Name$. Run it. 
When it asks, type your name, then press the &lt;Enter&gt; key. 
<H2>What's in a "Name$"?</H2>
<P>"Name$" is called a "variable". To be variable means that things can change. 
Try running the program again, but this time type in a friend's name (don't 
forget the &lt;Enter&gt; key). Sure enough, the message changes. 
<H2>INPUT</H2>
<P>INPUT Name$ takes what you type at the keyboard and puts it into the Name$ 
variable. PRINT Name$ prints out what is in the Name$ variable. 
<H2>Variables</H2>
<P>Variables hold letters and numbers. The dollar sign ($) means this variable 
can hold letters. These are called "string variables". Variables without a 
dollar sign can only hold numbers. We'll be seeing them soon.</P>
<P>You can call your variables anything you want. Try going back through this 
program and changing every "Name$" to "Fred$". What happens when you run 
it?</P><IMG src="Programming Tutorial_files/Variable.jpg" align=left> 
<P>Another way to think of a variable is to imagine a small bucket with a name 
on it. Put "Name$" on it. This is the bucket's (variable's) name. Now take a 
piece of paper and write your name on it and drop it into the imaginary bucket. 
Now the variable Name$ has your name in it. Computer variables can only hold one 
piece of paper (one value) at a time.</P><BR clear=all>
<H2>PRINT and Variables</H2>
<P>When you want to PRINT what's in a variable, leave off the double-quotation 
marks ("). This program will show you how this works:</P><CODE><PRE>    CLS
    INPUT "Enter your name: ", Name$
    PRINT "Name$"
    PRINT Name$
</PRE></CODE>
<P>The first PRINT statement prints Name$ on the screen. The second PRINT 
statement prints whatever name you entered.</P>
<H2>Learned</H2>
<UL>
  <LI>INPUT 
  <LI>Variables </LI></UL>
<HR>

<H1>Chapter 6 - IF...THEN</H1>
<P>Let's make that last program a little smarter. I want to be able to identify 
intruders playing with my programs. Wouldn't it be great if the computer could 
recognize someone's name and print a special message for them? How about 
this:</P><CODE><PRE>     CLS
     INPUT "Enter your name: ", Name$
     IF Name$="Mike" THEN 
       PRINT "Go Away!"
     ELSE
       PRINT "Hello, "; Name$; ".  How are you today?"
     END IF
</PRE></CODE>
<P>You can change the Name$="Mike" to Name$="Joe", or whoever you want to go 
away (like a brother or sister). Run the program and type in your name 
(hopefully it isn't Mike). You should see the same old message as before. Now 
run it again and try entering "Mike" (or "Joe" or whatever you changed it to). 
<H2>"Mike" Is Not The Same As "mike"</H2>
<P>If it didn't tell the right person to go away, make sure you typed the name 
correctly. In QBASIC, "Mike" is not the same as "mike", so if you don't type the 
first letter in upper-case, the program won't work. Make sure you enter the name 
exactly the way you put it in the program. 
<H2>IF...THEN</H2>
<P>The "IF..THEN..ELSE..END IF" statement in this program checks to see if Name$ 
has "Mike" in it. If so, then it does the PRINT statement after the "THEN". If 
Name$ isn't "Mike", it does the PRINT statement after the "ELSE". "END IF" tells 
QBASIC that the "IF" is over. 
<H2>Conditions</H2>
<P style="PAGE-BREAK-AFTER: auto">The Name$="Mike" portion of the IF...THEN is 
called the "condition". With numbers you can also check for "greater than" and 
"less than":</P><!-- None of these works at all --><!--<code STYLE="page-break-inside: avoid"><pre STYLE="page-break-inside: avoid">--><!--<code page-break-inside="avoid"><pre page-break-inside="avoid">--><CODE><PRE>     CLS
     INPUT "Enter a number: ", Number
     IF Number &lt; 100 THEN 
       PRINT "Your number was less than 100"
     ELSE
       PRINT "Your number was greater than or equal to 100"
     END IF
</PRE></CODE>
<P>If you want to check for "greater than", use "Number &gt; 100". Equals works 
just like before, "Number = 100". Another option is "not equal" which can be 
done like this: "Number &lt;&gt; 100".</P>
<P>IF...THEN is one of the most powerful features of QBASIC. Using IF...THEN can 
make your programs very interesting. It lets your program make decisions and do 
something appropriate.</P>
<H2>Learned</H2>
<UL>
  <LI>IF...THEN...ELSE </LI></UL>
<HR>

<H1 style="PAGE-BREAK-BEFORE: always">Chapter 7 - Numbers</H1>
<P>Computers are very good at math. Let's get the computer to do some math for 
us. Here's a simple multiplication calculator:</P><CODE><PRE>     CLS
     INPUT "Enter the first number: ", A
     INPUT "Enter the second number: ", B
     PRINT "The answer is: "; A * B
</PRE></CODE>
<P>If you have trouble finding the star (or asterisk "*") on the keyboard, it is 
usually above the number 8. Run it, and enter two numbers. It does an excellent 
job multiplying for you.</P>
<H2>Variables and Math</H2>
<P>A and B are variables, just like Name$. Unlike Name$, A and B do not have a 
dollar-sign after their names. This is because they are only holding numbers, 
not letters. 
<H2>Star</H2>
<P>"A * B" means "A times B". QBASIC doesn't use "X" for multiplication because 
you might want to have a variable called "X". 
<H2>What else?</H2>
<P>Try changing the "A * B" to "A - B" for subtraction. "A + B" will do 
addition, and "A / B" will do division. Why "/" for division? Because there's no 
division sign key on the keyboard. At least I haven't found one. 
<H2>Expressions</H2>
<P>"A * B", "A + B", "A - B", and "A / B" are called mathematical expressions, 
or simply "expressions". 
<H2>Learned</H2>
<UL>
  <LI>Variables with numbers 
  <LI>INPUT with numbers 
  <LI>Multiplication, Division, Addition, Subtraction 
  <LI>Expressions </LI></UL>
<HR>

<H1>Chapter 8 - Saving</H1>
<P>Before we get into some fairly big programs, let's look at how to save our 
masterpieces. 
<H2>Location Is Everything</H2>
<P>The first thing we need to think about is where we are going to save our 
programs. The two main places we can save things are the hard disk, and onto a 
floppy disk. Let's look at both places. 
<H2>Saving To Floppy</H2>
<P>Using a floppy is a good idea if you don't want other people looking at your 
programs. The floppy can be removed from the computer and kept in a safe place. 
Floppies are also good when you want to move programs from one computer to 
another. 
<P>Let's try it. Find a blank floppy and place it into the computer's floppy 
drive. The floppy can have stuff on it, as long as there is some free space 
left. You'll need to have a program up on the screen for this to work properly. 
Go back to the previous chapter and type in the example if you need to get 
something up on the screen. 
<P>Click on "File" on QBASIC's menu, then "Save". 
<P>The "Save" dialog will appear on the screen. Notice that the cursor is in a 
box (field) called "File Name:". Type this: <BR><BR><CODE><PRE>     a:\testsave
</PRE></CODE>
<P>Be careful with that backslash "\". It isn't the same as the front-slash "/" 
which is on the same key as the question mark "?". QBASIC is very picky about 
this. 
<P>Press the &lt;Enter&gt; key. What happened? Did you hear something? Where'd 
the "Save" dialog go? Hmmmm, ok, hopefully that worked. How can we check? Let's 
try loading the program back into QBASIC. Wait, it's already there. Ok, then 
let's clear it out and try to get it back from the floppy. Remember how to get 
rid of a program? Hint: "File" then "New" on the menu. 
<H2>Loading From Floppy</H2>
<P>Let's do it. Click on "File" then "Open..." on QBASIC's menu. Now you will 
see the "Open" dialog. Type this:</P><CODE><PRE>     a:
</PRE></CODE>
<P>and press the &lt;Enter&gt; key. Now you should see "TESTSAVE.BAS" in the box 
called "Files". Two clicks oughta do it. Double-click on "TESTSAVE.BAS" and the 
program is back from the floppy. 
<H2>Saving To Hard Disk</H2>
<P>The hard disk is the most convenient place to save programs. Since it is 
always in the computer, your programs are always there for you to load when you 
need them. 
<H2>Neatness Counts, Again</H2>
<P>Hard Disks usually have a lot more information on them than a floppy. Because 
of this, you need to be concerned about keeping things neat. You'll never be 
able to find what you need otherwise. The best way to organize your collection 
of programs is to put them into a "subdirectory" or "folder" on the hard disk. 
<H2>Making Your Own Subdirectory</H2>
<P>Let's make a folder on the hard disk for our programs. In Windows 95 we will 
need to use Windows Explorer. In Windows 3.1 we will use File Manager. First, 
the Windows 95 way. 
<H2>Making a Folder With Windows 95</H2>
<P>Click on the "Start" button, then "Programs", then "Windows Explorer". 
<P>Now click on "File", then "New &gt;", then "Folder" on the Windows Explorer 
menu. 
<P>Notice the words "New Folder" on the right-hand side of Windows Explorer. 
<P>Go ahead and type in a name for the new folder, but keep it short! QBASIC is 
an older program that can't handle names bigger than 8 letters or numbers. I 
called mine "TedsPrgs" meaning Ted's Programs. Call yours whatever you want, but 
no more than 8 characters, or it will look real funny to QBASIC. 
<P>Press the &lt;Enter&gt; key to create the folder. Good, that's done. We won't 
need to do that again, unless you'd like to make another directory at a later 
date. Go ahead and close Windows Explorer and get back to QBASIC. 
<H2>Making a Folder With Windows 3.1</H2>
<P>... 
<H2>Saving In The Directory</H2>
<P>Saving to the hard disk is only a little different from saving to a floppy. 
You'll need to have a program up on the screen to save. Go back to the previous 
chapter and type in the example if you need to get something up on the screen. 
<P>Click on "File" on QBASIC's menu, then "Save". 
<P>The "Save" dialog will appear on the screen. The cursor is in a box (field) 
called "File Name:". Type this:</P><CODE><PRE>     c:\TedsPrgs
</PRE></CODE>
<P>Once again, watch the backslash "\". Change "TedsPrgs" to whatever you named 
your directory. 
<P>Press the &lt;Enter&gt; key. Now you will see a list of programs in that 
directory. Since you haven't saved anything yet, there shouldn't be any programs 
there. Go ahead and type this: <BR><BR><CODE><PRE>     testsave
</PRE></CODE>
<P>and press the &lt;Enter&gt; key. Hmmm, no sound at all that time. Hard disks 
are much more quiet than floppies. So, let's make sure it worked properly. 
First, get rid of what's on the screen with a "File" then a "New". 
<H2>Loading From Hard Disk</H2>
<P>This is also very similar to the way we loaded a program from floppy. Click 
on "File" then "Open..." on QBASIC's menu. This will bring up the "Open" dialog. 
Type this: <BR><BR><CODE><PRE>     c:\TedsPrgs
</PRE></CODE>
<P>Like before, watch the backslash "\" and change "TedsPrgs" to whatever your 
folder was called. 
<P>Now you should see "TESTSAVE.BAS" in the "Files" box. Double-click on 
"TESTSAVE.BAS" to load it. 
<P>That wasn't too bad, was it? Once you figure out whether you want to save to 
floppy or hard disk, you only need to remember one way to save and load. 
<H2>Learned</H2>
<UL>
  <LI>Saving to floppy 
  <LI>Loading from floppy 
  <LI>Creating a folder 
  <LI>Saving to hard disk 
  <LI>Loading from hard disk </LI></UL>
<HR>

<H1 style="PAGE-BREAK-BEFORE: always">Chapter 9 - SELECT CASE</H1>
<P>IF...THEN...ELSE is fine if you only have two things you want to check. What 
if you have 5 or 6 friends that might use your computer and you want the 
computer to say something different to each of them? Try this:</P><CODE><PRE>     CLS
     INPUT "Enter your name: ", Name$
     SELECT CASE Name$
       CASE "Ted"
         PRINT "Greetings, oh powerful master"
       CASE "Mike"
         PRINT "Go away!"
       CASE ELSE
         PRINT "Hello, "; Name$; ".  How are you?"
     END SELECT
</PRE></CODE>
<P>Whew, that was a big one. Fortunately we learned how to save in Chapter 8. 
Save it if you want before running it. Feel free to change "Ted" and "Mike" to 
"Laura" and "Robin" or whoever. 
<H2>SELECT CASE</H2>
<P>SELECT CASE first checks Name$ for the value "Ted". If it finds it, it does 
the PRINT after the CASE "Ted". When the PRINT is done, it skips over the rest 
of the CASEs. It keeps checking against each CASE until it gets to CASE ELSE. If 
it hasn't found anything, it will do whatever is after the CASE ELSE. 
<H2>Just In CASE</H2>
<P>SELECT CASE can also be used with numbers as well as strings. Here's a quick 
example:</P><CODE><PRE>     CLS
     INPUT "Enter a number: ", Number
     SELECT CASE Number
       CASE 1234
         PRINT "Thank you for entering the secret number 1234"
       CASE 22
         PRINT "Well, 22 is an interesting number"
       CASE ELSE
         PRINT "You must not know the secret number"
     END SELECT
</PRE></CODE>
<H2>Learned</H2>
<UL>
  <LI>SELECT CASE </LI></UL>
<HR>

<H1 style="PAGE-BREAK-BEFORE: always">Chapter 10 - Equals</H1>
<P>So far, we've only let the user fill in our variables. We can fill in 
variables on our own inside our programs too. Like this:</P><CODE><PRE>     CLS
     A = 1
     B = 2
     A$ = "Hello"
     PRINT A
     PRINT B
     PRINT A$
</PRE></CODE>
<P>"A = 1" places the value 1 in the variable A. "B = 2" places the value 2 in 
the variable B. A$ = "Hello" places the string "Hello" in the variable A$. You 
get the picture. Then the program prints them out to prove to you that they are 
there.</P>
<P>See if you can figure out what this rather clever program will do. Then type 
it in and run it to see if you were right.</P><CODE><PRE>     CLS
     Count = 1
     DO
       PRINT Count
       Count = Count + 1
     LOOP
</PRE></CODE>
<P>Did you get it right? Did the output go by way too fast? You'll have to press 
Break to stop it. Then take a closer look and see if you can see what's going 
on.</P>
<P>That program is what is called a "counter". It counts 1, 2, 3, 4... until it 
is stopped.</P>
<HR>

<H1>Chapter 11 - Random Numbers</H1>
<P>Random numbers are numbers that you can't predict. Flipping a coin or rolling 
dice will give you a random number. Random numbers are very important in games 
and in some kinds of Math. Computers can generate random numbers pretty well. 
QBASIC's RND function provides random numbers that we can use.</P>
<H2>RND</H2>
<P>RND is a special function that gives us a random number between 0 and 1. We 
can use this in games to make things interesting. RND is perfect for rolling 
dice or flipping a coin. First let's see RND in action:</P><CODE><PRE>    CLS
    PRINT RND
    PRINT RND
</PRE></CODE>
<P>This program will print RND twice. Notice that you'll get two numbers that 
appear to be unpredictable and random. But, try running the program again. 
You'll get the same "random" numbers. This means your games would always be the 
same each time the user runs them. Fortunately, there's a way to fix this.</P>
<H2>RANDOMIZE TIMER</H2>
<P>Using RANDOMIZE TIMER will make sure the random numbers you get are different 
each time you run. Try this:</P><CODE><PRE>    CLS
    RANDOMIZE TIMER
    PRINT RND
    PRINT RND
</PRE></CODE>
<H2>Useful Random Numbers</H2>
<P>Random numbers between 0 and 1 aren't really very useful. What you will need 
for a game might be a random number between 1 and 6, like when you roll dice. To 
get something more useful, we'll use math. Fortunately, computers are very good 
at math.</P>
<P>There are two problems we must solve to get the results we want. First, the 
range of random numbers has to be expanded from 0 through 1 to 1 through 6. 
That's easily done like this:</P><CODE><PRE>    CLS
    RANDOMIZE TIMER
    PRINT RND * 6 + 1
    PRINT RND * 6 + 1
</PRE></CODE>
<P>By multiplying by 6, we increase the range to 0 through 5. By adding 1 we 
shift the range up to 1 through 6. However, there's still a problem. All that 
decimal stuff. QBASIC's INT function can be used to convert a decimal number to 
an integer (a number without a decimal).</P><CODE><PRE>    CLS
    RANDOMIZE TIMER
    PRINT INT(RND * 6 + 1)
    PRINT INT(RND * 6 + 1)
</PRE></CODE>
<H2>Roll the Dice</H2>
<P>Here's a program that rolls two dice and prints the value of each. The 
variables Die1 and Die2 are used to hold the values of each die before printing. 
In a real game, Die1 and Die2 would be used in some clever way to change the 
outcome of the game.</P><CODE><PRE>     CLS
     RANDOMIZE TIMER
     INPUT "Press ENTER to roll dice...", A$
     PRINT
     Die1 = INT(RND * 6 + 1)
     Die2 = INT(RND * 6 + 1)
     PRINT "Die 1: "; Die1
     PRINT "Die 2: "; Die2
</PRE></CODE>
<H2>PRINT By Itself</H2>
<P>Note that in the last program there was a PRINT on a line by itself. Did you 
see what it did? It simply printed a blank line on the screen. This can be 
useful for making the output from your program look nicer.</P>
<HR>

<H1 style="PAGE-BREAK-BEFORE: always">Chapter 12 - The Fortune Teller</H1>
<P>Here's a fun program that uses most of what we've learned so far to make a 
"Magic 8 Ball".</P><CODE><PRE>     CLS
     RANDOMIZE TIMER
     PRINT "I am the magical Fortune Teller."
     INPUT "Think of a question and press enter for your answer...", A$
     PRINT
     Answer = INT(RND * 5 + 1)
     SELECT CASE Answer
       CASE 1
         PRINT "Yes, definitely."
       CASE 2
         PRINT "Ask again, later."
       CASE 3
         PRINT "No way!"
       CASE 4
         PRINT "It is certain."
       CASE 5
         PRINT "Yes."
     END SELECT
</PRE></CODE>
<P>As always, go ahead and customize it. Change "No way!" to "You bet!" to get a 
Fortune Teller that never says "No". 
<H2>Adding CASEs</H2>
<P>Go ahead and try adding a new fortune. You'll need to change</P><CODE><PRE>Answer = INT(RND * 5 + 1)
</PRE></CODE>
<P>to</P><CODE><PRE>Answer = INT(RND * 6 + 1)
</PRE></CODE>
<P>since there will be 6 fortunes now. Then you will need to add a "<CODE>CASE 
6</CODE>" and a PRINT to print the new fortune.</P>
<HR>

<H1 style="PAGE-BREAK-BEFORE: always">Chapter 13 - DO...WHILE</H1>
<P>Back in Chapter 4 we saw a DO...LOOP that went forever. There are a number of 
ways to make a loop stop. One way is to use WHILE. This next program uses WHILE 
to make sure the program will only go as long as Answer$ has the letter "y" in 
it.</P><CODE><PRE>     CLS
     DO
       INPUT "Enter the first number: ", A
       INPUT "Enter the second number: ", B
       PRINT "The answer is: "; A * B

       INPUT "Would you like to do it again (y/n)? ", Answer$
     LOOP WHILE Answer$="y"
</PRE></CODE>
<P>The condition on the LOOP WHILE line is the same as a condition we might use 
in an IF...THEN. In this case, we check to see if Answer$="y", and if it does, 
we continue looping. If it doesn't, we fall out of the loop and our program 
ends.</P>
<P>You can add this feature to any program. Try adding it to the fortune 
teller.</P>
<HR>

<H1 style="PAGE-BREAK-BEFORE: always">Chapter 14 - OR and LEFT$</H1>
<P>That last program works great, as long as the user always types in a 
lowercase "y". What happens if the user types in "yes"? Since "yes" is not the 
same as "y" to the computer, the test for Answer$="y" will fail, and the program 
will end. Probably not a good idea. We have the same problem if our user enters 
a capital "Y". Try a few of these to see what I mean.</P>
<P>There are several ways to make this program smarter and easier to use for our 
users. We could have it check for a few different ways of saying yes by using 
"OR", like this:</P><CODE><PRE>     CLS
     DO
       INPUT "Enter the first number: ", A
       INPUT "Enter the second number: ", B
       PRINT "The answer is: "; A * B

       INPUT "Would you like to do it again (y/n)? ", Answer$
     LOOP WHILE Answer$="y" OR Answer$="Y"
</PRE></CODE>
<P>This version will allow the user to enter "y" or "Y" and the program will run 
again. We can get even more clever by using LEFT$ like this:</P><CODE><PRE>     CLS
     DO
       INPUT "Enter the first number: ", A
       INPUT "Enter the second number: ", B
       PRINT "The answer is: "; A * B

       INPUT "Would you like to do it again? ", Answer$
       FirstLetter$ = LEFT$(Answer$, 1)
     LOOP WHILE FirstLetter$="y" OR FirstLetter$="Y"
</PRE></CODE>
<P>This version will let the user enter "Yes", "yes", or just about anything 
that starts with a "y" because LEFT$ is used to only look at the first character 
in their answer. You could even enter "yep" or "YEAH!" and the program will 
begin again.</P>
<P>This may seem to make the computer smarter, but we know what's really going 
on. To prove the computer really isn't very smart, try entering "sure" or 
"yellow". It thinks "sure" is "no", and "yellow" is "yes".</P>
<H2>LEFT$</H2>
<P>LEFT$ can be used to take a certain number of letters from the left side of a 
string variable. As an example, if we have:</P><CODE><PRE>    A$="TEST"
</PRE></CODE>
<P>Then LEFT$(A$,2) will give us "TE". LEFT$(A$,3) will give us "TES". The first 
"parameter" you pass to LEFT$ is the string you want to work with. The second 
parameter you pass to LEFT$ is the number of characters (letters) you want. 
Let's try a program that uses LEFT$ in a different way:</P><CODE><PRE>    INPUT "Enter something:", A$
    PRINT A$
    PRINT LEFT$(A$,1)
    PRINT LEFT$(A$,2)
    PRINT LEFT$(A$,3)
</PRE></CODE>
<P>This program will print the first character of whatever you enter, followed 
by the first two characters, followed by the first three characters:</P><CODE><PRE>    Enter something: Jack
    Jack
    J
    Ja
    Jac
</PRE></CODE>
<P>QBASIC also provide a RIGHT$() in case you were curious, and it works just 
like LEFT$(). Try this:</P><CODE><PRE>    INPUT "Enter something:", A$
    PRINT A$
    PRINT RIGHT$(A$,1)
    PRINT RIGHT$(A$,2)
    PRINT RIGHT$(A$,3)
</PRE></CODE>
<P>Here's an example of what that program will do:</P><CODE><PRE>    Enter something: Jack
    Jack
    k
    ck
    ack
</PRE></CODE>
<HR>

<H1 style="PAGE-BREAK-BEFORE: always">Chapter 15 - COLOR</H1>
<P>Tired of all this black and white? Then the COLOR statement is for you. Try 
this program for size:</P><CODE><PRE>    CLS
    COLOR 2, 0
    PRINT "That's ";
    COLOR 3, 0
    PRINT "more ";
    COLOR 5, 0
    PRINT "like it!"
</PRE></CODE>
<P>Color takes two numbers. The first number is the foreground color. The second 
number is the background color. For example, if you want to print black on white 
instead of white on black, use "COLOR 0,7". The colors each have their own 
number:</P>
<UL>
  <LI>0 - Black 
  <LI>1 - Blue 
  <LI>2 - Green 
  <LI>3 - Cyan 
  <LI>4 - Red 
  <LI>5 - Magenta 
  <LI>6 - Yellow 
  <LI>7 - White </LI></UL>
<P>There are plenty of other colors too. Try the numbers from 8 through 15 to 
see what colors you get. Basically, if you add 8 to any of the above colors, you 
get brighter versions of the same color. Take blue which is 1 and add 8 and you 
get 9 which is bright blue.</P>
<H2>Blinking</H2>
<P>Adding 16 to a color number gives you a blinking version. This doesn't work 
in a DOS window, though. Press &lt;ALT&gt;&lt;ENTER&gt; to switch to full-screen 
mode which will show the blinking. Try this program:</P><CODE><PRE>    CLS
    COLOR 28, 0
    PRINT "*** WARNING ***"
    COLOR 15, 0
    PRINT "Programming can be too much fun!"
</PRE></CODE>
<P>Color can be used in many ways to make your programs more interesting.</P>
<HR>

<H1>Chapter 16 - FOR...NEXT</H1>
<H2>A New Counter</H2>
<P>FOR...NEXT is a loop like DO...LOOP, but a FOR...NEXT loop has its own 
counter built in. Try this:</P><CODE><PRE>    CLS
    FOR I = 1 TO 10
      PRINT I
    NEXT I
</PRE></CODE>
<P>Much better than our last counter. This one stops on its own after counting 
to 10.</P>
<H2>A Color Chart</H2>
<P>Here's a color chart program using a FOR...NEXT loop.</P><CODE><PRE>    CLS
    FOR I = 1 TO 15
      COLOR I, 0
      PRINT I; "*** COLOR ***"
    NEXT I
</PRE></CODE>
<H2>STEP</H2>
<P>FOR...NEXT can also do "step counting". Try this:</P><CODE><PRE>    CLS
    FOR I = 2 TO 20 STEP 2
      PRINT I
    NEXT I
</PRE></CODE>
<P>That will count by 2's from 2 to 20. STEP tells QBASIC what to count by. Try 
changing it to count by 10's from 10 to 100.</P>
<P>FOR...NEXT can also count backwards if you use a negative STEP 
value:</P><CODE><PRE>    CLS
    FOR I = 10 TO 1 STEP -1
      PRINT I
      SLEEP 1
    NEXT I
    PRINT "BLAST OFF!"
</PRE></CODE>
<P>"SLEEP 1" tells QBASIC to wait for one second, then continue.</P>
<HR>

<H1>Chapter 17 - Sound</H1>
<P>If you just need a beep in your program, you can use BEEP:</P><CODE><PRE>    CLS
    INPUT "Press Enter to hear a beep", A$
    BEEP
</PRE></CODE>
<P>SOUND lets you play a beep and tell it how high or low the beep will be, and 
how long it will last. This program makes a 1000Hz beep for about 1 
second:</P><CODE><PRE>    SOUND 1000, 18
</PRE></CODE>
<P>SOUND is good for making sound effects. Here's a bomb dropping:</P><CODE><PRE>    FOR I = 4000 TO 1000 STEP -5
      SOUND I, .1
    NEXT I
</PRE></CODE>
<P>If you want to play a song, PLAY is exactly what you need. Try 
this:</P><CODE><PRE>    PLAY "e8 d8 c8 d8 e8 e8 e4"
</PRE></CODE>
<P>PLAY is like a little programming language inside of QBASIC. "e8" means play 
an eighth note "e". If you are familiar with sheet music, this will make sense. 
Here's a scale:</P><CODE><PRE>    PLAY "c8 d8 e8 f8 g8 a8 b8 &gt; c4"
</PRE></CODE>
<P>The "&gt;" greater than sign means "go up one octave". There are many more 
special commands in PLAY. Check the QBASIC help for a list of all of them.</P>
<H2>PLAY and Triplets</H2>
<P>Here's a familiar tune that uses a trick to do triplets.</P><CODE><PRE>    PLAY "T180 &lt;d8d8d8 T120 g2&gt;d2"
    PLAY "T180 c8&lt;b8a8 T120 &gt;g2d4"
    PLAY "T180 c8&lt;b8a8 T120 &gt;g2d4"
    PLAY "T180 c8&lt;b8&gt;c8 T120 &lt;a2&gt;"
</PRE></CODE>
<P>Since PLAY doesn't do triplets, you have to modify the tempo to get the right 
rhythm. PLAY begins with a default tempo of "T120" which means 120 quarter notes 
per minute. In the above song, we switch to T180 which is the triplet tempo for 
T120. By multiplying our tempo by 1.5, we get the triplet tempo. When the 
triplets are done, we switch back to the regular tempo. You can see in the above 
example that we switch back and forth between the main tempo (T120) and the 
triplet tempo (T180) several times as needed.</P>
<P>As with everything, there's more than one way to do triplets. 8th note 
triplets can also be called 12th notes, like this:</P><CODE><PRE>    PLAY "&lt;d12d12d12g2&gt;d2"
    PLAY "c12&lt;b12a12&gt;g2d4"
    PLAY "c12&lt;b12a12&gt;g2d4"
    PLAY "c12&lt;b12&gt;c12&lt;a2&gt;"
</PRE></CODE>
<P>Using this technique, 16th note triplets are 24th notes, etc.... You just 
multiply the note value by 1.5 instead of changing the tempo.</P>
<P>Each of these techniques has its advantages and disadvantages. The 
tempo-changing technique uses more space, but the notes retain their values. The 
12th note technique is more compact, but not as easy to understand. Which one 
you use is up to you. Just make sure the next person to read your code 
understands what you are doing. Comments are a good idea.</P>
<HR>

<H1>Chapter 18 - LOCATE</H1>
<P>LOCATE allows you to print in a specific place on the screen.</P><CODE><PRE>    CLS
    LOCATE 5, 10
    PRINT "Here"
    LOCATE 20, 70
    PRINT "There"
</PRE></CODE>
<P>The two numbers after LOCATE are the coordinates where the print will be. 
Just like coordinates in math class, these numbers give the row and the column. 
The first number in LOCATE is the row, or how far down the screen the print will 
start. The second number is the column, or how far over the print will 
start.</P>
<P>Let's use some random numbers, COLOR and LOCATE to make a more interesting 
version of our first looping program:</P><CODE><PRE>    CLS
    DO
      Row = INT(RND * 23 + 1)
      Column = INT(RND * 79 + 1)
      LOCATE Row, Column
      Color1 = INT(RND * 15 + 1)
      COLOR Color1, 0
      PRINT "Ted was here!";
    LOOP
</PRE></CODE>
<P>Kind of messy, but interesting.</P>
<P>How about a clock?</P><CODE><PRE>    CLS
    DO
      LOCATE 1, 1
      PRINT TIME$
      SLEEP 1
    LOOP
</PRE></CODE>
<P>TIME$ is a special variable that contains the current time. Press Break to 
stop.</P>
<HR>

<H1>Chapter 19 - WIDTH</H1>
<P>Use WIDTH 40 for big text. It changes the entire screen to wide text mode. 
Use WIDTH 80 to go back to normal size text.</P><CODE><PRE>    SCREEN 0
    WIDTH 40
    CLS
    PRINT "Wow!  This is big!"
    INPUT "Press &lt;Enter&gt; to go back", A$
    WIDTH 80
    PRINT "That's more like it."
</PRE></CODE>
<P>Unfortunately, you won't see the big text in a window. You'll have to press 
&lt;Alt&gt;-&lt;Enter&gt; to switch to full-screen mode. Be sure to press 
&lt;Alt&gt;-&lt;Enter&gt; again to switch back to window mode.</P>
<HR>

<H1>Chapter 20 - CHR$</H1>
<P>There are many special symbols and other characters you can display that 
aren't on the keyboard. Try this:</P><CODE><PRE>    CLS
    PRINT CHR$(1); CHR$(2)
</PRE></CODE>
<P>That prints a couple of smiley faces. There are plenty of other characters 
too. This program will show you many, but not all of them:</P><CODE><PRE>    CLS
    FOR I = 32 to 255
      PRINT I; CHR$(I); "  ";
    NEXT I
</PRE></CODE>
<HR>

<H1>Chapter 21 - Graphics</H1>
<P>So far, we've only been dealing with text (words and numbers). How do we do 
pictures in QBASIC? First, we need to use SCREEN to change from text mode to 
graphics mode.</P>
<H2>SCREEN</H2>
<P>SCREEN lets you select a "graphics" screen instead of the "text" screen we've 
been using. This will let you draw pictures. In the next program, we'll use DRAW 
to draw a square on the screen in SCREEN 12 graphics mode.</P><CODE><PRE>    SCREEN 12
    CLS
    DRAW "D100 R100 U100 L100"
</PRE></CODE>
<P>There are many other SCREEN numbers you can use, but 12 is probably the 
easiest to work with. It gives you a lot of space and the color numbers are 
familiar. QBASIC Help explains all the possible values of SCREEN. You can always 
try them and see what happens.</P>
<H2>DRAW</H2>
<P>DRAW is kind of like the turtle in the programming language Logo. With DRAW, 
you can move around the screen and draw lines along the way. In the above 
example we used the following DRAW commands:</P>
<UL>
  <LI>D100 - Go down 100 units 
  <LI>R100 - Go right 100 units 
  <LI>U100 - Go up 100 units 
  <LI>L100 - Go left 100 units </LI></UL>
<P>DRAW can do a lot more than that. It is like PLAY. It's a small programming 
language inside of QBASIC. Look at QBASIC Help for a complete description of 
everything it can do. Here's a filled in box:</P><CODE><PRE>    SCREEN 12
    CLS
    DRAW "C15 D100 R100 U100 L100 BF1 P15,15"
</PRE></CODE>
<P>"C15" sets the color to bright white. "BF1" moves into the square, then 
"P15,15" fills it with bright white. Finally, here's something very 
Logo-like:</P><CODE><PRE>    SCREEN 12
    CLS
    FOR I = 0 TO 360 STEP 10
      DRAW "D100 R100 U100 L100 TA" + STR$(I)
    NEXT I
</PRE></CODE>
<P>"TA" means to turn to a specific angle. STR$ converts the value in I to a 
string. This lets DRAW turn to the angle in the variable I. It's not quite as 
easy as Logo, but it's still pretty impressive.</P>
<H2>LINE</H2>
<P>QBASIC also lets you draw using a coordinate system. It's like drawing graphs 
on graph paper. Try this:</P><CODE><PRE>    SCREEN 12
    CLS
    LINE (0, 0)-(320, 240), 15
</PRE></CODE>
<P>LINE lets you draw a line between two points. The points are specified in (x, 
y) coordinates. You may have seen this when learning about graphs in math class. 
In QBASIC, the coordinates are almost the same. The only thing that is different 
is the Y coordinate. In QBASIC, the Y coordinate is upside down. "0" is at the 
top, and bigger numbers go toward the bottom of the screen.</P>
<P>"LINE (0, 0)-(320, 240), 15" draws a line starting at coordinate (0, 0) which 
is the upper left corner of the screen. The line ends at (320, 240) which is the 
center of the screen. The last number is the color (15 which is bright 
white).</P>
<H2>Box</H2>
<P>By adding a "B" to the end of a LINE statement, you can draw a box. Try 
this:</P><CODE><PRE>    SCREEN 12
    CLS
    LINE (0, 0)-(320, 240), 15, B
</PRE></CODE>
<P>The first coordinate is the upper left corner while the second coordinate is 
the lower right.</P>
<P>Try "BF" instead of "B". Interesting?</P>
<H2>CIRCLE</H2>
<P>QBASIC can also draw circles using the CIRCLE statement:</P><CODE><PRE>    SCREEN 12
    CLS
    CIRCLE (320, 240), 100, 15
</PRE></CODE>
<P>The coordinate (320, 240) tells the computer where to put the center of the 
circle. "100" is the radius, or how big the circle will be. "15" is the color 
number (bright white again).</P>
<H2>PAINT</H2>
<P>Notice how that circle was not filled in. LINE has a "BF" option that will 
let us fill in the boxes it draws. CIRCLE has no such option, so we have to use 
PAINT:</P><CODE><PRE>    SCREEN 12
    CLS
    CIRCLE (320, 240), 100, 15
    PAINT (320, 240), 15, 15
</PRE></CODE>
<P>PAINT fills an area with a color. It stops painting when it runs into a 
certain color on the screen. The coordinate (320, 240) tells PAINT where to 
start filling in, and the first "15" tells PAINT to use bright white as the 
paint color. The second "15" tells PAINT to stop painting when it runs into 
anything that is bright white.</P>
<H2>Circle Art</H2>
<P>Concentric circles are very easy to draw:</P><CODE><PRE>    SCREEN 12
    CLS
    FOR I = 5 TO 200 STEP 5
      CIRCLE (320, 240), I, 15
    NEXT I
</PRE></CODE>
<P>With CIRCLE, PAINT and some random numbers, we can make some interesting 
pictures:</P><CODE><PRE>    SCREEN 12
    CLS
    FOR I = 1 TO 50
      X = INT(RND * 640)
      Y = INT(RND * 480)
      R = INT(RND * 100)
      Color1 = INT(RND * 16)
      CIRCLE (X, Y), R, Color1
      PAINT (X, Y), R, Color1, Color1
    NEXT I
</PRE></CODE>
<HR>

<H1>Chapter 22 - INKEY$</H1>
<P>Up to now, we've been using INPUT to get things from the keyboard. The 
problem with INPUT is that our program stops until the user presses the enter 
key. Wouldn't it be nice to keep the program running and still be able to get 
input from the keyboard? INKEY$ will let you do this. Using INKEY$ is very 
important if you want to make "real-time" game programs.</P>
<P>Let's fix the clock program to let the user press any key to stop the 
program. This way the user doesn't have to know about the Break key.</P><CODE><PRE>    CLS
    LOCATE 3, 1
    PRINT "Press any key to exit"
    DO
      LOCATE 1, 1
      PRINT TIME$
      SLEEP 1
    LOOP WHILE INKEY$ = ""
</PRE></CODE>
<P>Not bad at all. Now we don't need to teach the user about the Break key. We 
can do the same thing in any of our other programs that need the Break key. If 
the user does not press a key, INKEY$ returns nothing or "".</P>
<P>This next program will sit in a loop getting keys from the keyboard with 
INKEY$ and printing them to the screen:</P><CODE><PRE>    CLS
    DO
      Key$ = INKEY$
      IF Key$ &lt;&gt; "" THEN
        PRINT Key$;
      END IF
    LOOP
</PRE></CODE>
<P>That little program can be used to find the various secret codes used by 
INKEY$ to let you know the arrow keys have been pressed. This is very useful in 
game programming where the arrow keys might control a player in a game. If you 
press an arrow key, you'll see that a space and a letter are generated.</P>
<HR>

<H1>Chapter 22.5 - String Functions</H1>
<H2>Concatenation</H2>
<P>Concat-uh-what?! It's just a fancy word for putting things together, one 
after another. It's much easier done than said. When you use the plus-sign "+" 
with strings, it doesn't add them up. Instead, it puts them together.</P><CODE><PRE>    A$ = "Hello "
    B$ = "there!"
    C$ = A$ + B$
    PRINT C$
</PRE></CODE>
<P>That will print "Hello there!" to the screen.</P>
<H2>LEFT$() and RIGHT$()</H2>
<P>LEFT$() and RIGHT$() let you work with parts of strings. Try this 
example:</P><CODE><PRE>    A$ = "Ted Felix"
    B$ = LEFT$(A$, 3)
    PRINT B$
</PRE></CODE>
<P>LEFT$(A$, 3) means "take 3 characters from the left of A$". Since the 3 
characters on the left happen to be "Ted", this program prints "Ted" as 
expected. Try changing the number to 2 or 5 and see what happens.</P>
<P>Once you understand LEFT$(), RIGHT$() is easy. Let's try it:</P><CODE><PRE>    A$ = "QBASIC is cool"
    B$ = RIGHT$(A$, 4)
    PRINT B$
</PRE></CODE>
<P>RIGHT$(A$, 4) means "take 4 characters from the right of A$". This gives us 
"cool".</P>
<H2>MID$()</H2>
<P>LEFT$() gives us something from the left side of a string. RIGHT$() gives us 
something from the right side of the string. MID$() gives us something from the 
middle of a string. Try this:</P><CODE><PRE>    A$ = "one two three"
    B$ = MID$(A$, 5, 3)
    PRINT B$
</PRE></CODE>
<P>MID$(A$, 5, 3) means "take 3 characters from the middle of A$, starting at 
the fifth character". This gives us the word in the middle: "two".</P>
<P>You can also use MID$() to change a portion of what is in a string variable. 
Try this:</P><CODE><PRE>    A$ = "cabinet"
    PRINT A$
    MID$(A$, 4, 2) = "ar"
    PRINT A$
</PRE></CODE>
<P>Here, we replaced the "in" in cabinet with "ar". This gives us a completely 
different word.</P>
<P>This would be a pretty sneaky way to hide something like a password in a 
program. Someone who didn't know how to program in QBASIC might not be able to 
figure it out.</P>
<H2>LCASE$() and UCASE$()</H2>
<P>If you need to convert a string to all uppercase or all lowercase, UCASE$() 
and LCASE$() are exactly what you need.</P><CODE><PRE>    A$ = "Fly Away With Me"
    PRINT A$
    PRINT UCASE$(A$)
    PRINT LCASE$(A$)
</PRE></CODE>
<P>You can use UCASE$() and LCASE$() to do "case-insensitive" tests. In other 
words, upper and lower case are ignored. Here's an improvement to a previous 
program.</P><CODE><PRE>    CLS
    INPUT "Enter your name: ", Name$
    IF LCASE$(Name$) = "mike" THEN 
      PRINT "Go Away!"
    ELSE
      PRINT "Hello, "; Name$; ".  How are you today?"
    END IF
</PRE></CODE>
<P>In this new version, the user can type "mike", "Mike" or even "MIKE" and the 
name will be recognized.</P>
<H2>STRING$() and SPACE$()</H2>
<P>Let's say you need to print 20 stars on the screen in a line. You could do it 
like this:</P><CODE><PRE>    PRINT "********************"
</PRE></CODE>
<P>But, there has got to be a better way. How about with a FOR loop?</P><CODE><PRE>    FOR I = 1 to 20
      PRINT "*";
    NEXT I
    PRINT
</PRE></CODE>
<P>That works well, but QBASIC provides an even easier way to do this with 
STRING$().</P><CODE><PRE>    PRINT STRING$(20, "*")
</PRE></CODE>
<P>The first argument to STRING$() is the number of times you want a character 
repeated. The second argument is the character you want to repeat. So, 
STRING$(20, "*") means "give me 20 stars".</P>
<P>If you want to print a lot of spaces, you could do it with 
STRING$():</P><CODE><PRE>    PRINT "A"; STRING$(20, " "); "B"
</PRE></CODE>
<P>Or you can use SPACE$().</P><CODE><PRE>    PRINT "A"; SPACE$(20); "B"
</PRE></CODE>
<P>FOR loops always make things interesting:</P><CODE><PRE>    FOR I = 0 to 20
      PRINT SPACE$(I); "QBASIC!"
    NEXT I
</PRE></CODE>
<H2>LEN()</H2>
<P>LEN() gives you the length of a string. Try this:</P><CODE><PRE>    A$ = "Hello"
    PRINT LEN(A$)
</PRE></CODE>
<P>As expected, that should print the number 5 since the word "Hello" has 5 
characters.</P>
<P>LEN() is handy in FOR loops when you aren't sure how long the string is, and 
you don't feel like counting it yourself:</P><CODE><PRE>    A$ = "Hello QBASIC!"
    FOR I = 1 to LEN(A$)
      PRINT LEFT$(A$, I)
    NEXT I
</PRE></CODE>
<P>LEN() is very useful when you want the user to provide the string. Try 
this:</P><CODE><PRE>    INPUT "Enter a string: ", A$
    PRINT "The string you entered was"; LEN(A$); "characters long."
</PRE></CODE>
<H2>CHR$() and ASC()</H2>
<P>Computers really only know about numbers. To make strings of letters, 
computers convert letters to numbers so they can work with them. CHR$() and 
ASC() let you do the same kinds of conversions.</P>
<P>CHR$() converts a number to a character. We've already seen this in a 
previous chapter. Try this:</P><CODE><PRE>    FOR I = 14 to 255
      PRINT I; CHR$(I); "  ";
    NEXT I
</PRE></CODE>
<P>That program displays all the character numbers from 14 through 255 followed 
by the characters that they represent. CHR$() is very useful for getting 
characters that aren't on the keyboard. Like this:</P><CODE><PRE>    PRINT STRING$(40, CHR$(1))
</PRE></CODE>
<P>There are some very interesting characters between CHR$(1) and CHR$(31). As 
an example, CHR$(7) makes a beep. Try it:</P><CODE><PRE>    PRINT CHR$(7)
</PRE></CODE>
<P>There are other interesting things as well. Play around with CHR$() a bit, 
and you'll find several.</P>
<P>ASC() is the opposite of CHR$(). ASC() takes a character and tells you its 
number. Try this:</P><CODE><PRE>    PRINT ASC("A")
</PRE></CODE>
<P>That program prints 65 because the character code for a capital "A" is 65. 
The code that QBASIC uses to convert letters to numbers is called "ASCII" 
(pronounced "askee").</P>
<H2>INSTR()</H2>
<P>INSTR() lets you search for a string in another string. If it finds the 
string, it will tell you where it is. Try this:</P><CODE><PRE>    A$ = "Hello everyone"
    PRINT INSTR(A$, "every")
</PRE></CODE>
<P>That program prints "7" because "every" is found at the 7th position in 
"Hello everyone". If the string isn't found, INSTR() returns zero.</P>
<P>INSTR() can come in very handy when you want to break a string into 
pieces:</P><CODE><PRE>    A$ = "two pieces"
    SpacePos = INSTR(A$, " ")
    PRINT LEFT$(A$, SpacePos)
    PRINT RIGHT$(A$, LEN(A$) - SpacePos)
</PRE></CODE>
<HR>

<H1>Chapter 23 - Comments and Constants</H1>
<P>Most programming languages allow you to add notes to your programs that are 
ignored by the computer. This lets you explain what you've done to someone else 
who might read your program later. In QBASIC we use the apostrophe (') to begin 
a comment. Here's an example:</P><CODE><PRE>    ' A program to draw boxes all over the screen
    ' This is a comment, QBASIC will ignore it
    SCREEN 12
    CLS
    ' Draw 50 boxes
    FOR I = 1 TO 50
      ' Pick the location of the box
      X1 = INT(RND * 640)
      Y1 = INT(RND * 480)
      X2 = INT(RND * 640)
      Y2 = INT(RND * 480)
      ' Pick the color for the box
      Color1 = INT(RND * 16)
      ' Draw the box
      LINE (X1, Y1) - (X2, Y2), Color1, BF
    NEXT I
</PRE></CODE>
<P>The computer will ignore all those comment lines, but us humans can read them 
and remember how a program works. Good programmers use comments to help others 
understand what they have done. Comments can also help us remember what we did 
when we come back to a program after working on something else for a while.</P>
<H2>Constants</H2>
<P>Another way to make your programs easier to understand is to use constants. 
Constants look and act like variables, but they cannot be changed. Here's a 
useful program:</P><CODE><PRE>    CONST Pi = 3.141593
    INPUT "Enter the radius of a circle: ", Radius
    PRINT "The circumference is:"; 2 * Pi * Radius
    PRINT "The area is:"; Pi * Radius * Radius
</PRE></CODE>
<P>If we didn't use the constant Pi, we would have to copy the number 3.141593 
two places in the above program. Using a constant makes the program easier to 
read and understand. It also keeps us from making mistakes when copying.</P>
<HR>

<H1>Chapter 24 - Sub-Procedures (SUBs)</H1>
<P>When programs get big, you need to break them into smaller pieces that are 
easier to work with. QBASIC calls these pieces "sub-procedures" or SUBs. Other 
programming languages have other names, like procedures, subroutines, or 
subprograms.</P>
<P>To work with SUBs in QBASIC, we need to look at the "SUBs" dialog box which 
shows us a list of our SUBs. Select "View | SUBs..." from the menu to bring up 
the SUBs dialog box. You can also press the F2 key to get there more quickly. In 
here, you can select a SUB to work with, or you can select the main module. If 
you are just starting with a clean slate (File | New) you'll see that the main 
module is called "Untitled", and there are no SUBs.</P>
<P>You can define a new SUB in QBASIC simply by typing it in. This will jump you 
to the view of the new SUB. Try typing this:</P><CODE><PRE>    SUB DrawCircle
      CIRCLE (320, 240), 100, 15
    END SUB
</PRE></CODE>
<P>Notice that after you pressed enter on the first line, you were taken to a 
new screen with just your new SUB in it. Now, if you go to the SUBs dialog box 
(View | SUBs...), you can see that you have a SUB named "DrawCircle" and a Main 
Module named "Untitled".</P>
<P>Now we need to go back to the Main Module ("Untitled") to actually use the 
new SUB. From the menu, select View | SUBs... to get the SUBs dialog box. Now 
double-click on "Untitled" to get back to the Main Module. The screen will go 
blank, but don't worry, your SUB is still out there. Now type this in and run 
it:</P><CODE><PRE>    SCREEN 12
    CLS
    DrawCircle
</PRE></CODE>
<P>See? DrawCircle did what it was supposed to do.</P>
<P>Let's try adding another SUB. See if you can remember the steps on your own. 
Refer back to the previous example if you need help.</P><CODE><PRE>    SUB PlayMary
      PLAY "e8 d8 c8 d8 e8 e8 e4"
    END SUB
</PRE></CODE>
<P>Now we need to change the Main Module to use our new SUB. So, go back to the 
Main Module, and change it to look like this:</P><CODE><PRE>    SCREEN 12
    CLS
    DrawCircle
    PlayMary
</PRE></CODE>
<P>Now run it and you should see the circle and hear the song.</P>
<P>Dividing programs into smaller pieces like this will help you make sense out 
of big programs.</P>
<H2>Arguments</H2>
<P>Sometimes you want to pass numbers or strings to a SUB. QBASIC lets you do 
this. Here is a new version of the DrawCircle SUB:</P><CODE><PRE>    SUB DrawCircle2 (Radius)
      CIRCLE (320, 240), Radius, 15
    END SUB
</PRE></CODE>
<P>This version lets us pass in the Radius. When we do this, Radius is called a 
"parameter" or "argument" to our SUB. Here's how we would then pass an argument 
from the Main Module:</P><CODE><PRE>    SCREEN 12
    CLS
    DrawCircle
    DrawCircle2 (20)
    PlayMary
</PRE></CODE>
<P>We could also do something like this in our Main Module:</P><CODE><PRE>    SCREEN 12
    CLS
    FOR I = 5 TO 200 STEP 5
      DrawCircle2 (I)
    NEXT I
</PRE></CODE>
<H2>Changing Arguments</H2>
<P>If you need to tell the main module something, you can change one of the 
arguments in your SUB, and the main module will see the change.</P><CODE><PRE>    SUB AddOne(X)
      X = X + 1
    END SUB

    CLS
    I = 0
    AddOne(I)
    PRINT I
</PRE></CODE>
<P>When you run that program, it will print the value 1 on the screen. This is 
because the value of I is changed by the AddOne SUB. If you only need to return 
one value, a FUNCTION is sometimes a better choice. FUNCTIONs are described 
later.</P>
<H2>Scope</H2>
<P>What if we had variables in the Main Module and in a SUB that happen to have 
the same name. Would they be the same variable? Let's find out. Enter this 
SUB:</P><CODE><PRE>    SUB Scope
      PRINT "Scope says: "; X
      X = 23
    END SUB
</PRE></CODE>
<P>And this Main Module:</P><CODE><PRE>    X = 15
    Scope
    PRINT "Main Module says: "; X
</PRE></CODE>
<P>And run it. What happened? Scope said "0" because to Scope, X was a new 
variable. Main Module said 15, because Scope didn't change Main Module's X, it 
changed it's own X. Scope's X and Main Module's X are different variables.</P>
<P>Variables that you create in a SUB cannot be seen by the Main Module. 
Variables in the Main Module cannot be seen by a SUB. If you need to share 
variables, you can pass them as arguments to the SUB.</P>
<H2>Global Data</H2>
<P>It is possible to make variables in the Main Module available to SUBs without 
passing them as arguments. Most programmers consider this dangerous since you 
never know who might change those variables. Add a "SHARED X" to the Scope SUB 
like this:</P><CODE><PRE>    SUB Scope
      SHARED X
      PRINT "Scope says: "; X
      X = 23
    END SUB
</PRE></CODE>
<P>Now when you run it, you'll see that Scope can now see the Main Module's X. 
Scope no longer has its own X. This is called "Global Data", and should be 
avoided if you can.</P>
<P>You can also make a variable global to all SUBs from the Main Module like 
this:</P><CODE><PRE>    DIM SHARED X
</PRE></CODE>
<H2>Object Oriented Programming</H2>
<P>When you start worrying about SUBs and the Main Module sharing variables, you 
are probably ready to begin learning Object Oriented programming. Object 
Oriented programming makes it easier to share variables between SUBs and still 
write code that is easy to understand. Visual BASIC, Java, and C# are 
programming languages that provide Object Oriented programming features, and are 
fairly easy to learn.</P>
<H2>STATIC</H2>
<P>Notice that each time you call a SUB, its variables are lost after the SUB is 
over. Here's an example:</P><CODE><PRE>    SUB Counter
      C = C + 1
      PRINT C
    END SUB

    CLS
    Counter
    Counter
    Counter
</PRE></CODE>
<P>Not a very good counter, since it always prints "1". We can use STATIC to 
tell QBASIC that we don't want C to go away after the SUB is over. Then we will 
get the behavior we expect. Change the Counter SUB like this:</P><CODE><PRE>    SUB Counter
      STATIC C
      C = C + 1
      PRINT C
    END SUB
</PRE></CODE>
<P>That's much better.</P>
<P>Object Oriented programming languages offer many ways to avoid the use of 
STATIC variables. If you find yourself making lots of STATIC variables, it is 
probably time to learn an Object Oriented programming language.</P>
<H2>Functions</H2>
<P>Functions are just like SUBs, but they return a value. Here's an 
example:</P><CODE><PRE>    FUNCTION Add (X, Y)
      Add = X + Y
    END FUNCTION
</PRE></CODE>
<P>And here's a Main Module to go with it:</P><CODE><PRE>    PRINT Add(3, 4)
</PRE></CODE>
<H2>Well, I DECLARE!</H2>
<P>As you've been entering the example programs in this chapter, you may have 
noticed that the QBASIC editor adds "DECLARE" statements to the programs. Why 
does it do this? The DECLARE statement is a warning to QBASIC to let it know 
that there are SUBs or FUNCTIONs in this program. Without this warning, QBASIC 
would have no idea what we mean when we call a SUB or FUNCTION. It would think 
it had found a syntax error and the program would stop.</P>
<P>Fortunately, QBASIC handles making DECLAREs for us. Unfortunately, in larger 
programs, it might put the DECLAREs someplace that looks ugly. Fortunately, you 
can move the DECLAREs anywhere you want (as long as it is before the FUNCTION or 
SUB is first used) and QBASIC still takes care of the rest.</P>
<HR>

<H1>Chapter 25 - Data Structures</H1>
<H2>Built-In Types</H2>
<P>QBASIC offers five built-in types. Each of these types can be specified by a 
single character after the variable name. You can also specify a type using a 
DIM statement. It is important to pick the right types when you are writing a 
program. The following descriptions of each type will help you make the right 
decisions.</P>
<H3>Single-Precision</H3>
<P>The single-precision type handles numbers with decimals. You can go up to 
seven digits with a single-precision variable. In a DIM statement, use "SINGLE" 
to create a single-precision variable. The type-character for a single-precision 
variable is "!". Unless you do something special, any variable without a type 
character is single-precision. Here are some examples of creating and using 
single-precision variables:</P><CODE><PRE>    X = 1.5
    DIM Y AS SINGLE
    Y = 2.1
    Z! = 2.5

    PRINT X; Y; Z!
</PRE></CODE>
<P>Notice that the DIM statement can be used to tell QBASIC the type of a 
variable. Then you don't need to use a type character for that variable.</P>
<H3>String</H3>
<P>The string type handles strings of characters. You cannot do math with string 
variables. In a DIM statement, use "STRING" to create a string variable. The 
type-character for a string variable is "$". Here are some examples of creating 
and using string variables:</P><CODE><PRE>    X$ = "Hello"
    DIM Y AS STRING
    Y = "Goodbye"

    PRINT X$
    PRINT Y
</PRE></CODE>
<H3>Integer</H3>
<P>The integer type handles numbers without decimals. Integers may range from 
-32768 to 32767. Math with integers may be faster than math with 
single-precision variables. For programs that have to run very fast, using 
integers might be useful. In a DIM statement, use "INTEGER" to create an integer 
variable. The type-character for an integer variable is "%". Here are some 
examples of creating and using integer variables:</P><CODE><PRE>    X% = 32
    DIM Y AS INTEGER
    Y = 55

    PRINT X%; Y
</PRE></CODE>
<P>Since math with integers is very fast, you will commonly see the following 
line near the beginning of QBASIC programs:</P><CODE><PRE>    DEFINT A-Z
</PRE></CODE>
<P>This tells QBASIC to stop assuming that every variable is single-precision, 
and instead to assume that all variables are integers. This way you don't need 
to use DIM or the "%" symbol throughout your program to make all your variables 
integers.</P>
<H3>Long-Integer</H3>
<P>The long-integer type handles numbers without decimals. Long-integers may 
range from -2147483648 to 2147483647. Math with long-integers is usually almost 
as fast as math with integers. For programs that have to run very fast, using 
long-integers might be useful. In a DIM statement, use "LONG" to create a 
long-integer variable. The type-character for a long-integer variable is 
"&amp;". Here are some examples of creating and using long-integer 
variables:</P><CODE><PRE>    X&amp; = 65536
    DIM Y AS LONG
    Y = 121072

    PRINT X&amp;; Y
</PRE></CODE>
<H3>Double-Precision</H3>
<P>The double-precision type handles numbers with decimals. You can go up to 
fifteen digits with a double-precision variable. Double-precision variables are 
used where very accurate math is needed. In a DIM statement, use "DOUBLE" to 
create a double-precision variable. The type-character for a double-precision 
variable is "#". Here are some examples of creating and using double-precision 
variables:</P><CODE><PRE>    X# = 3.14159265358979
    DIM Y AS DOUBLE
    Y = 1.23456789012345

    PRINT X#; Y
</PRE></CODE>
<H2>Arrays</H2>
<P>An array lets you store a list of things. Arrays are very similar to 
variables, but they hold more than one thing. Try this:</P><CODE><PRE>    N$(0) = "Ted"
    N$(1) = "Jack"
    N$(2) = "Jill"
    N$(3) = "Fred"

    FOR I = 0 TO 3
      PRINT N$(I)
    NEXT I
</PRE></CODE>
<P>The number inside the parenthesis "(1)" is called the "subscript". N$(0) is 
usually pronounced "N dollar sub zero", although I've also heard it called "N 
string sub zero".</P>
<P>Arrays can also store numbers.</P><CODE><PRE>    FOR I = 0 TO 10
      A(I) = I * 2
    NEXT I

    FOR I = 0 TO 10
      PRINT A(I)
    NEXT I
</PRE></CODE>
<P>Arrays are limited to holding only 11 items (0 through 10). If you go over 
10, you'll get a "Subscript out of range" error. To make bigger arrays, you can 
use DIM to tell QBASIC how big the array will be:</P><CODE><PRE>    DIM A(20)

    FOR I = 0 TO 20
      A(I) = I * 2
    NEXT I

    FOR I = 0 TO 20
      PRINT A(I)
    NEXT I
</PRE></CODE>
<P>Arrays are perfect for programs that need to keep a list of things. You could 
use arrays to make a phone book program, or a program that keeps track of the 
people in your class at school.</P>
<H2>TYPE</H2>
<P>Sometimes you'll want to put a bunch of different kinds of variables together 
because all together they describe something. QBASIC's TYPE statement lets you 
create your own collections of variables. Here's an example:</P><CODE><PRE>    TYPE FriendType
      FullName AS STRING * 20
      PhoneNumber AS STRING * 14
    END TYPE

    DIM Friend AS FriendType

    Friend.FullName = "Joe Blow"
    Friend.PhoneNumber = "1-310-555-1212"

    PRINT Friend.FullName; ": "; Friend.PhoneNumber
</PRE></CODE>
<P>TYPE makes our new type, or collection of variables. DIM makes a new variable 
of that type. When we work with types, we use the variable name, followed by a 
dot ("."), followed by the name of the variable in the TYPE.</P>
<P>Since TYPE lets you use a single variable to represent a collection of 
variables, you can use TYPE to pass many parameters to a SUB at once. This may 
be a good way to avoid using SHARED too much in a SUB.</P>
<P>In QBASIC, a TYPE can hold any of the built-in types. A TYPE can also hold 
another TYPE. However, a TYPE cannot hold an array. Visual BASIC allows that, 
but not QBASIC.</P>
<H2>A Database</H2>
<P>Using arrays and TYPEs together allows you to create what is known as a 
database. Try this:</P><CODE><PRE>    TYPE FriendType
      FullName AS STRING * 20
      PhoneNumber AS STRING * 14
    END TYPE

    ' The database
    DIM Friends(2) AS FriendType

    ' Fill the database with names and numbers
    Friends(0).FullName = "Joe Blow"
    Friends(0).PhoneNumber = "1-310-555-1212"

    Friends(1).FullName = "Jack Sprat"
    Friends(1).PhoneNumber = "1-340-555-6545"

    Friends(2).FullName = "Carol Christmas"
    Friends(2).PhoneNumber = "1-350-555-2421"

    ' Print out the entire database
    FOR I = 0 TO 2
      PRINT Friends(I).FullName; ": "; Friends(I).PhoneNumber
    NEXT I
</PRE></CODE>
<HR>

<H1>Chapter 25.5 - Type Conversion</H1>
<H2>STR$() and VAL()</H2>
<P>Up to now, we've been using string variables to hold strings and number 
variables to hold numbers. What if we really need to do some math with numbers 
that are in a string variable? Or maybe we need to get some numbers into a 
string variable somehow. QBASIC provides the STR$() and VAL() functions to help 
us out.</P>
<P>STR$() will let us convert from a number to a string. Like this:</P><CODE><PRE>  A = 25        ' A can only hold numbers
  PRINT A
  B$ = STR$(A)  ' Convert A to a string, store in B$
  PRINT B$
</PRE></CODE>
<P>VAL() will let us convert from a string to a number. Like this:</P><CODE><PRE>  A$ = "25"    ' Can't do any math with a string variable
  PRINT A$
  B = VAL(A$)  ' Convert A$ to a number, store in B
  PRINT B
</PRE></CODE>
<H2>Converting Numbers</H2>
<P>Need to cover CINT(), FIX(), INT(), CDBL(), CSNG(), CLNG() 
<HR>

<H1>Chapter 25.75 - PRINT USING</H1>
<HR>

<H1>Chapter 25.9 - DATA and READ</H1>
<P>Loading an array with a lot of values can get pretty boring.</P><CODE><PRE>  ' Load up the array
  A(0) = 10
  A(1) = 24
  A(2) = 31
  A(3) = 15
  A(4) = 67
  A(5) = 34
  A(6) = 87
  A(7) = 92
  A(8) = 14
  ' ... This could go on for quite a while

  FOR I = 0 TO 8
    PRINT A(I)
  NEXT I
</PRE></CODE>
<P>To save space, and typing, QBASIC provides the DATA and READ statements. You 
can place a list of data values in a DATA statement and read them into an array 
using READ. The following program will do exactly what the previous program 
does.</P><CODE><PRE>  DATA 10, 24, 31, 15, 67, 34, 87, 92, 14

  FOR I = 0 TO 8
    READ A(I)
  NEXT I

  FOR I = 0 TO 8
    PRINT A(I)
  NEXT I
</PRE></CODE>
<P>QBASIC skips the DATA statements in the code. It only pays attention to them 
when it finds a READ statement. Each time a READ happens, QBASIC takes a value 
from the DATA statement and places it in the variable in the READ statement.</P>
<H2>RESTORE</H2>
<P>RESTORE tells QBASIC which DATA statement to start READing from. You might 
need to load several different arrays in your program. RESTORE lets you organize 
the DATA statements any way you want.</P><CODE><PRE>  Names:
  DATA Fred, Joe, Jack, Sue
  Values:
  DATA 10, 24, 31, 15, 67, 34, 87, 92, 14

  ' Start with the DATA statement after "Values:"
  RESTORE Values
  FOR I = 0 TO 8
    READ A(I)
  NEXT I

  ' Start with the DATA statement after "Names:"
  RESTORE Names
  FOR I = 0 TO 8
    READ N$(I)
  NEXT I
</PRE></CODE>
<P>RESTORE tells QBASIC to start reading at the next DATA statement after a 
label. A label is a name like "Names:" or "Values:". Notice that when we make a 
new label, we use a colon ":", but when we use the label in the RESTORE 
statement, we drop the colon.</P>
<H2>Loading a Database</H2>
<P>DATA statements are perfect for loading a database. Here's a new version of 
the database example using DATA statements this time.</P><CODE><PRE>    DATA "Joe Blow", "1-310-555-1212"
    DATA "Jack Sprat", "1-340-555-6545"
    DATA "Carol Christmas", "1-350-555-2421"

    TYPE FriendType
      FullName AS STRING * 20
      PhoneNumber AS STRING * 14
    END TYPE

    ' The database
    DIM Friends(2) AS FriendType

    ' Read in the database from the DATA statements
    FOR I = 0 TO 2
      READ Friends(I).FullName, Friends(I).PhoneNumber
    NEXT I

    ' Print out the entire database
    FOR I = 0 TO 2
      PRINT Friends(I).FullName; ": "; Friends(I).PhoneNumber
    NEXT I
</PRE></CODE>
<HR>

<H1>Chapter 26 - Reading and Writing Files</H1>
<P>Up to now, our programs have depended on us, the programmer, to give them 
data to work with. This wouldn't work very well for a phone book program. The 
user should be the one to fill in the names and phone numbers. QBASIC will let 
us get information from the user with INPUT. But when the program ends, that 
information is gone.</P>
<H2>Writing to a file</H2>
<P>The solution to this problem is to let the user enter their information, then 
the program will store that information in a file on the hard disk. QBASIC 
offers a number of ways to do this. Try this:</P><CODE><PRE>    INPUT "Enter your name: ", Name$
    OPEN "testfile.txt" FOR OUTPUT AS #1
    WRITE #1, Name$
    CLOSE #1
</PRE></CODE>
<P>When you run that program, and enter your name, it will place your name in a 
file on the hard disk called "testfile.txt". You can use Notepad to find it and 
make sure your name is there. You might need to figure out where QBASIC put the 
file. That can be a little tricky. If you exit QBASIC, and from the DOS prompt 
enter this:</P><CODE><PRE>  type testfile.txt
</PRE></CODE>
<P>You should see your name, or whatever you entered. The "type" command at the 
DOS prompt copies the contents of a file to the screen. You could also try 
this:</P><CODE><PRE>  notepad testfile.txt
</PRE></CODE>
<P>That should bring up notepad with your file. When you are working with files, 
it is a good idea to know how to bring them up in notepad. This way you can look 
at them to see if they contain what you expected.</P>
<H2>OPEN, WRITE, and CLOSE</H2>
<P>There are three statements, OPEN, WRITE, and CLOSE that are needed to write 
information to a file. The OPEN statement tells QBASIC three things: 
<OL>
  <LI>The name of the file (testfile.txt) 
  <LI>Whether we want to write to the file (OUTPUT) or read from the file 
  (INPUT) 
  <LI>The file number (#1 in this example) </LI></OL>
<P>Once the file is opened, we will use the file number to let QBASIC know which 
file we want to write to. You could have many files open at the same time, so 
the file number lets QBASIC know which file you want to work with.</P>
<P>The WRITE statement tells QBASIC which file we want to write to (#1), and 
what we want to write (Name$). It is very much like a PRINT statement, but 
instead of sending the information to the screen, WRITE sends the information to 
a file.</P>
<P>Finally, we need to CLOSE the file, to let QBASIC know that we are done. 
Otherwise, QBASIC might not write anything to the file at all. The CLOSE 
statement only needs to know which file you want to close, so it only requires 
the file number.</P>
<H2>Reading from a file</H2>
<P>The following program will get the name and print it on the screen:</P><CODE><PRE>    OPEN "testfile.txt" FOR INPUT AS #1
    INPUT #1, Name$
    CLOSE #1
    PRINT Name$
</PRE></CODE>
<P>There are three main things that are different in this program if you compare 
it to the previous program.</P>
<OL>
  <LI>The OPEN statement uses "INPUT" instead of "OUTPUT". This tells QBASIC 
  that we plan to get data from the file. 
  <LI>The INPUT statement, which you've seen before, is used to read from a 
  file. The #1 tells it that we want to read from file #1. When we've used INPUT 
  in other programs, there was no #1. Without a file number, INPUT gets 
  information from the keyboard. With a file number, it gets information from a 
  file. 
  <LI>Instead of getting something from the user at the beginning of the 
  program, we display what was read from the file at the end with a good ol' 
  PRINT statement. </LI></OL>
<P>One thing that hasn't changed at all is the CLOSE statement. We CLOSE file #1 
so that QBASIC knows we are done with it. While we probably won't lose any data 
if we don't CLOSE in this case, it is still a good thing to do. QBASIC can only 
open so many files, so if you leave some open, you might not be able to open any 
more.</P>
<H2>Logging</H2>
<P>Sometimes it can be very useful to write to a file while a program is running 
so that you can look at what happened later. This is called "logging". We can 
use the "APPEND" option in the OPEN statement to open a file and simply keep 
adding to the end of it.</P><CODE><PRE>  OPEN "logfile.txt" FOR APPEND AS #1
  PRINT #1, "Program Run: "; TIME$
  CLOSE #1

  CLS
  INPUT "What is your name"; Name$
  PRINT "Hello, "; Name$

  OPEN "logfile.txt" FOR APPEND AS #1
  PRINT #1, "Program Stopped: "; TIME$
  CLOSE #1
</PRE></CODE>
<P>We've logged two things in this program, the program's start time, and it's 
end time. Run the program a few times, then exit QBASIC and type:</P><CODE><PRE>  notepad logfile.txt
</PRE></CODE>
<P>That will show you what is in your log.</P>
<H2>Input Files</H2>
<P>Ideas: Fortune Teller using a text file as input. This would combine file 
input with arrays.</P>
<H2>Keeping Track of Things</H2>
<P>Let's say we want our program to remember who it is registered to. We also 
want it to count how many times it has been run. We could try something like 
this:</P><CODE><PRE>  CLS
  INPUT "Enter your name to register this program: ", Name$
  PRINT "Thank you, "; Name$
  RunCount = RunCount + 1
  PRINT "This program is registered to: "; Name$
  PRINT "This program has been run"; RunCount; "times."
  PRINT "We hope you have enjoyed it."
</PRE></CODE>
<P>But that doesn't work. Why? Because QBASIC can't remember the value of the 
variables Name$ and RunCount from one run of the program to the next.</P>
<P>To fix this, we need to use a file. We can read the file before the program 
starts, and write the file back out when the program is finished. We will save 
the user's name and the number of times the program has been run in this 
file.</P>
<P>The code to do this is a bit more complex than what we've done so far. This 
is because QBASIC handles file errors in a strange way. Our program must handle 
one file error. The first time it is run, there will be no registration file for 
it to read. So the OPEN will fail. We have to handle this, or our program won't 
work.</P><CODE><PRE>' If there are any problems, QBASIC will jump to ErrorHandler below.
ON ERROR GOTO ErrorHandler

' This is the error code that is filled in by the error handler
DIM ErrorCode AS INTEGER

CLS

' Always reset this before doing something you want to check
ErrorCode = 0
' Try to get the name and run count from the file
OPEN "register.txt" FOR INPUT AS #1

' If the file wasn't found
IF ErrorCode = 53 THEN
  ' Get the name from the user
  INPUT "Enter your name to register this program: ", Name$
  PRINT "Thank you, "; Name$
  ' And set the run count to 0
  RunCount = 0
ELSE
  ' Get the user's name and the run count from the file
  INPUT #1, Name$, RunCount
  CLOSE #1
END IF

RunCount = RunCount + 1
PRINT "This program is registered to: "; Name$
PRINT "This program has been run"; RunCount; "times."
PRINT "We hope you have enjoyed it."

' Save the name and run count for the next run
OPEN "register.txt" FOR OUTPUT AS #1
WRITE #1, Name$, RunCount
CLOSE #1

' This END prevents us from running the error handler at the
' end of the program.  It causes the program to stop, just
' like pressing the Break key.
END

' QBASIC will jump here if an error occurs
ErrorHandler:
' We have to move the error code into a variable or we won't
' see it because ERR is set to zero after the handler is done.
ErrorCode = ERR
RESUME NEXT
</PRE></CODE>
<H2>Handling File Errors</H2>
<P>"ON ERROR GOTO ErrorHandler" tells QBASIC that if there is a problem, the 
program should immediately jump to "ErrorHandler:" which you will see near the 
end of the program. There we can get the error code which is in a QBASIC 
variable called "ERR" and copy it to our own variable "ErrorCode". If we don't 
do this, we will lose the error code stored in ERR. RESUME NEXT tells QBASIC to 
continue from where the error occurred.</P>
<P>I try very hard to avoid using GOTO in my programs. Programs that use GOTO 
can be very hard to understand. Unfortunately, in this case, QBASIC leaves us 
with no alternative. We have to use a GOTO. So, I've tried to come up with the 
simplest solution that keeps the code from being too hard to follow. With this 
little error handler in place, we can simply assume that ErrorCode will contain 
the error number when something goes wrong. Just don't forget to reset it or you 
will be looking at old errors!</P>
<H2>Binary I/O</H2>
<P>As opposed to...<BR>How to do it.<BR>What is the difference? Unformatted, 
unreadable. <BR>Why is it a good thing? Small, unreadable to prying eyes, fast. 
<BR>Sample: Write out a few numbers and strings. Examine with notepad. Read them 
back in.</P>
<H2>Random I/O</H2>
<P>Up to this point we have been using what is called "Sequential I/O". 
Sequential means "one after another". I/O stands for Input/Output. When we write 
the user's name and the run count to the file, we write them one after another. 
This is sequential output. When we read the name and run count, we read them one 
after another. Name first, then run count. This is sequential input. All 
together, this adds up to Sequential Input and Output, or Sequential I/O.</P>
<P>Random I/O lets you read and write data to any part of a file in any order 
you want. It is very useful when you have very large files, and you don't have 
enough time or memory to read everything in the file sequentially (one after 
another). Random I/O lets you jump right to the data you want in a file, and 
read or write it.</P>
<P>Even in very large and complex programs, Random I/O is rarely used due to its 
complexity. Imagine if the program has a bug and it writes to the wrong location 
in the file. The file could be destroyed because of this. We won't cover Random 
I/O here. But, if you need it, it's in QBASIC.</P>
<HR>

<H1>Chapter 27 - Sample Programs</H1>
<H2>Read the Manual</H2>
<P>You've learned a lot. If you've made it through this far, and you are still 
having fun, then it's time to make up some of your own programs. QBASIC's help 
is what you should read through whenever you are curious about everything else 
QBASIC can do. It can do a lot more than what I've shown you in this book.</P>
<P>Some of the samples that follow may do things that you haven't seen mentioned 
in the book. See if you can find out what these new things are by looking them 
up in the help that comes with QBASIC.</P>
<H2>Number Guesser</H2>
<P>In this game, the computer picks a number between 1 and 10. You have to try 
and guess the number.</P><CODE><PRE>    CLS
    RANDOMIZE TIMER
    PRINT "Welcome to Number Guesser"
    PRINT "I'm thinking of a number between 1 and 10."
    Number = INT(RND * 10 + 1)
    DO
      INPUT "What is your guess? ", Guess
      IF Guess = Number THEN
        PRINT "Correct!"
        EXIT DO
      ELSE
        PRINT "Try again"
      END IF
    LOOP
</PRE></CODE>
<H2>Addition Facts</H2>
<H2>Alarm Clock</H2>
<H2>More Samples</H2>
<P>I have a few more samples on my "SupaSoft" website. Just look for "QBASIC". 
Here are a few that you can find there:</P>
<P><I>Note: If you are typing in these web addresses, make sure you use capital 
letters exactly the way they are shown. For example, make sure you type 
"SupaSoft", not "supasoft". If you are getting "Not Found" messages in your web 
browser, this is probably why.</I></P>
<P><A 
href="http://tedfelix.com/SupaSoft/snowflak.html">http://tedfelix.com/SupaSoft/snowflak.html</A> 
- Snowflake: Snowflake Generator.</P>
<P><A 
href="http://tedfelix.com/SupaSoft/strsplt2.html">http://tedfelix.com/SupaSoft/strsplt2.html</A> 
- Star Split 2: Starfield simulation.</P>
<P><A 
href="http://tedfelix.com/SupaSoft/willtell.html">http://tedfelix.com/SupaSoft/willtell.html</A> 
- William Tell: Pretend to be William Tell and try to shoot the arrow off your 
victim's head.</P>
<P><A 
href="http://tedfelix.com/SupaSoft/capture.html">http://tedfelix.com/SupaSoft/capture.html</A> 
- Capture: Try to trap two robots in a maze of blocks.</P>
<P><A 
href="http://tedfelix.com/SupaSoft/index.html">http://tedfelix.com/SupaSoft/index.html</A> 
- My freeware site. Look for QBASIC in the program descriptions to find the 
QBASIC samples.</P>
<HR>
<A name=appa>
<H1 style="PAGE-BREAK-BEFORE: always">Appendix A - Finding and Installing 
QBASIC</H1></A>
<P>If you see a message like "Bad command or file name" then you need to get 
QBASIC on your machine.<BR><BR><IMG 
src="Programming Tutorial_files/BadCommand.jpg"> 
<P>Unfortunately this isn't the easiest thing in the world to do. You might want 
to get someone to walk through this with you. 
<H2>On the Internet</H2>
<P>There are several places on the internet where you can get a copy of qbasic. 
Usually the file is called "qbasic.zip". Here are some places I've found it: 
<UL>
  <LI><A 
  href="http://www.svatopluk.com/qbtutor/tut1.htm">http://www.svatopluk.com/qbtutor/tut1.htm</A> 
  - QBASIC tutorial at <A href="http://www.svatopluk.com/">King Svatopluk's 
  Court</A> </LI></UL>
<P>There are probably a lot of other places to find it too. Using a search 
engine like <A href="http://www.google.com/">http://www.google.com/</A> and 
searching for "qbasic.zip" usually does a good job. If you end up looking for 
qbasic this way, be sure to get the "version 1.1 interpreter". That is the 
version of qbasic I used to write this book. It is the most easy to use, and 
least complicated. Once you are used to 1.1, you can try and find 4.5 which has 
some very nice features.</P>
<P>Once you have qbasic.zip, you then need to unzip it and move qbasic.exe and 
qbasic.hlp to c:\windows\command . Someone who is familiar with "zip" files can 
help you do this.</P>
<H2>Windows 95</H2>
<P>QBASIC is on the Windows 95 CD-ROM. Put the Windows 95 CD in your CD-ROM 
drive. It will pop-up a window that you can go ahead and close (click on the "X" 
in the upper right corner of the window). 
<H3>DOS Or Windows?</H3>
<P>There are two ways to get the QBASIC files onto your computer. Using the DOS 
prompt is the fastest method, but you need to know your CD-ROM drive's drive 
letter (e.g. "d:", "e:" or "z:"). The method described in the "Windows Explorer" 
section is a bit slower, but you don't need to know the CD-ROM drive's drive 
letter. 
<H3>DOS Prompt</H3>
<P>You should already be at a DOS prompt from trying to start QBASIC. This makes 
things easier. I am going to assume your CD-ROM drive is drive letter "d:". If 
it isn't, substitute the correct drive letter in the "copy" command below. Type 
the following (&lt;Enter&gt; means "Press the &lt;Enter&gt; key"): 
<BR><BR><CODE><PRE>     c: &lt;Enter&gt;
     cd \windows\command &lt;Enter&gt;
     copy d:\other\oldmsdos\qbasic.* &lt;Enter&gt;
</PRE></CODE>
<P>That should have copied qbasic.exe and qbasic.hlp to your computer. Skip to 
the "Finished" section to check if all went well. 
<H3>Windows Explorer</H3>
<P>If you don't want to try the DOS method, Windows Explorer can also be used to 
get QBASIC on your computer. We need Windows Explorer (not Internet Explorer) to 
copy the QBASIC files from the CD and into your c:\windows\command directory. 
Click on the "Start" button, then "Programs", then "Windows Explorer". On the 
left you will see a list of the drives on your computer. Look for the CD-ROM 
drive (it has a little picture of a CD and it should say "Windows95" next to 
it). Click on the picture. In the right column you will see a list of 
directories on the CD. 
<P><B>Finding QBASIC.</B>&nbsp;&nbsp;&nbsp; Double-Click on "Other", then 
double-click on Oldmsdos. Now you will see a list of files. Go through the list 
until you find the two files with the name Qbasic. One is QBASIC itself, and the 
other is a help file. 
<P><B>Selecting the two QBASIC files.</B>&nbsp;&nbsp;&nbsp; We want to copy 
these two files to the c:\windows\command directory. Click on the first Qbasic 
file to turn it blue. This means it is selected. We also need the other Qbasic 
file. Press and hold the &lt;Ctrl&gt; key while you click on the other Qbasic 
file. They should both be blue now. This means they are both selected. 
<P><B>Copying To The Clipboard.</B>&nbsp;&nbsp;&nbsp; Press the &lt;Ctrl&gt; key 
and hold it down while pressing the C key. This will copy the files to the 
clipboard. 
<P><B>Destination C:\Windows\Command.</B>&nbsp;&nbsp;&nbsp; Now click on "Tools" 
on the Windows Explorer menu, then click on "Go To...". Type this: <BR><CODE><PRE>     c:\windows\command
</PRE></CODE>and press the &lt;Enter&gt; key. 
<P><B>Pasting From The Clipboard.</B>&nbsp;&nbsp;&nbsp; Now press the 
&lt;Ctrl&gt; key and hold it down while pressing the V key. This will paste the 
qbasic files from the clipboard and into the c:\windows\command directory. 
<H2>Finished</H2>
<P>Whew! That should do it. 
<P>You can close Windows Explorer (if you used it), get back to your DOS prompt 
window (<CODE>C:\WINDOWS&gt;<BLINK>_</BLINK></CODE> or 
<CODE>C:\WINDOWS\COMMAND&gt;<BLINK>_</BLINK></CODE>) and type: <BR><CODE><PRE>     qbasic
</PRE></CODE>and press the &lt;Enter&gt; key. 
<HR>

<H1>More QBASIC Tutorials</H1>
<UL>
  <LI><A href="http://www.geocities.com/progsharehouse/qbtutor/index.htm">QBASIC 
  Tutorial at The Programming Sharehouse</A> 
  <LI><A href="http://www.qbasic.com/tutorial.shtml">QBASIC Tutorial at 
  qbasic.com</A> 
  <LI><A href="http://www.enteract.com/~dandd/basic/">QBASIC Tutorial from 
  D&amp;D's website</A> 
  <LI><A 
  href="http://directory.google.com/Top/Computers/Programming/Languages/BASIC/QBasic_and_QuickBasic/Tutorials/">Google's 
  list of QBASIC tutorials</A> </LI></UL>
<HR>

<H1>Linkography</H1>
<UL>
  <LI><A 
  href="http://www.network54.com/Forum/13959">http://www.network54.com/Forum/13959</A><BR>QBASIC 
  Forum - talk to other folks who use QBASIC. 
  <LI><A 
  href="http://www.ethanwiner.com/">http://www.ethanwiner.com/</A><BR>Ethan 
  Winer's site - His book "BASIC Techniques and Utilities" is available for 
  download here. 
  <LI><A 
  href="http://piptol.qbasicnews.com/webring/goring.php?action=all">http://piptol.qbasicnews.com/webring/goring.php?action=all</A> 
  - The QBASIC web ring - lots of other interesting QBASIC sites. 
  <LI><A href="http://www.libertybasic.com/">http://www.libertybasic.com/</A> - 
  Another flavor of BASIC for windows. I don't recommend LibertyBASIC, because 
  its graphics support is difficult to use. It is very important that a 
  programming language have an easy way for kids to play with graphics. 
  <LI><A 
  href="http://www.davebsoft.com/Teaching/GraphTlk/">http://www.davebsoft.com/Teaching/GraphTlk/</A> 

  <LI><A 
  href="http://www.qwerty.com/basic.htm">http://www.qwerty.com/basic.htm</A> 
  <LI><A 
  href="http://www.octonline.com/usr/wdawe/qbasic.htm">http://www.octonline.com/usr/wdawe/qbasic.htm</A> 

  <LI><A 
  href="http://www.conklinsystems.com/retro/trsman.shtml">http://www.conklinsystems.com/retro/trsman.shtml</A> 
  </LI></UL>
<HR>

<H1>Bibliography</H1>
<H2>Recommended Reading</H2>
<P><B>"QBASIC by Example"</B>, Greg M. Perry - One of the last QBASIC books 
still in print. A really good book that has the right attitude. Teaches the 
right way to program with QBASIC. I only took issue with the fact that TYPE is 
introduced in the random file I/O chapter instead of earlier alongside arrays. 
The fact that TYPE is the first step toward object oriented programming makes it 
very important to introduce it on its own.</P>
<P><B>"Absolute Beginner's Guide to QBASIC"</B>, Greg M. Perry - Perry's earlier 
book. Out of print, but very good.</P>
<P><B>"Microsoft QuickBASIC Bible"</B>, The Waite Group - Comprehensive 
reference, although I don't like the way GOTOs are used and introduced. While 
the authors are cautious to warn against the use of GOTOs, they proceed to use 
them in their SELECT CASE examples. No examples are given of the limited 
situations when GOTOs are appropriate. Other than this, a very good 
reference.</P>
<H2>More Titles</H2>
<P>Here are some titles I've found at Amazon. I don't know anything about these 
since I haven't reviewed them. On Amazon, browse by subject to: "Computers &amp; 
Internet &gt; Programming &gt; Languages &amp; Tools &gt; QBASIC" to find even 
more.</P>
<P><B>"QBasic for Beginners"</B>, Fenton, et al.</P>
<P><B>"Qbasic"</B>, Susan K. Baumann, et al. - Apparently, this one was used in 
high schools to teach QBASIC.</P>
<P><B>"QBASIC Programming for Dummies"</B>, Douglas A. Hergert - The famous 
Dummies series. Reviewers at Amazon indicate that this book isn't as gentle as 
it should be.</P>
<P><B>"Programming With Qbasic"</B> (Prisma Be an Expert! Series: Computerbooks 
for Young People) ISBN 1-853-65346-2 Special Order from www.amazon.com.</P>
<P><B>"Building with BASIC: A Programming Kit for Kids"</B> Gayle Arthur, Alpha 
Books 1992, ISBN 0-672-30057-5. Uses QBASIC. Out of Print.</P>
<P><B>"QBASIC for Students"</B>, Michael Trombetta</P>
<P><B>"QBASIC Using Subprograms 2nd ed"</B>, James S. Quasney</P>
<P><B>"Quickbasic and QBASIC Using Modular Structure"</B>, Julia Case Bradley 
There are two editions, one from 10/1993 and one from 11/1995 called the 
"Alternate Edition" that includes some added Visual BASIC info.</P>
<P>My old TRS-80 books that I learned from:</P>
<P><B>"TRS-80 Micro Computer System: User's Manual for Level 1"</B>, Dr. David 
A. Lien. This is the book I started with back in 1979. A PDF copy is available 
at <A href="http://www.trs-80.com/">http://www.trs-80.com/</A></P>
<P><B>"TRS-80 Level-II"</B>, Dr. David A. Lien</P><PRE></PRE>
<HR>

<P>Copyright 2004, Ted Felix, All Rights Reserved <BR>May be copied freely for 
non-commercial use. </P></BODY></HTML>
